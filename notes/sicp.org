#+TITLE:       SICP Learning Notes And Exersice
#+AUTHOR:      Kelvin Hu
#+EMAIL:       ini.kelvin@gmail.com
#+DATE:        2012-12-10 Sun
#+KEYWORDS:    sicp
#+CATEGORY:    notes
#+TAGS:        :SICP:
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+DESCRIPTION: learning notes of book Structure and Interpretation of Computer Programs

这里记录了我在学习SICP的过程中的一点笔记，以及作业解答，现在还正在学习中。。
（因为作业太多了，读起来真慢。。）

* 构造过程抽象

** 求值模型

   - 正则序求值：先将复合式代入实际参数，再逐渐展开，直到得到一个只包含基本运算符的表达式，
     再对其进行求值。（完全展开而后归约）

   - 应用序求值：对于复合型表达式，将能进行计算的一些子表达式求值，再对其进行展开，再求值能
     够进行计算的子表达式，直到求出最终结果。（展开一层归约一层）

** 练习1.2

   : (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

** 练习1.3
   : the answer below is wrong!!!
   : (define (sum-of-max-two a b c)
   :     (cond ((< a b) (if (< a c) (+ b c) (+ a b)))
   :           (else (if (< b c) (+ a c) (+ a b)))))

** 练习1.5

   初看到 =(define (p) (p))= 这样的定义吓了我一跳，细看其实是一个递归函数的定义，但由没
   有退出条件，所以一旦有 =(p)= 这样的调用，程序将陷入死循环。

   再看 =(test 0 (p))= ，如果是正则序，那么会完全展开再求值，于是会有如下过程：
   : 1. (if (= 0 0) 0 (p))
   : 2. (if #t 0 (p))
   : 3. return value, 0
   如果是应用序，则会先求值 =(p)= ，于是程序陷入死循环。

** 练习1.6

   这个题目看了半天，大概猜到是跟求值模型相关的，但在解释器racket上试，和使用原始版本的if
   结果一模一样。。

   于是，无奈Google之，发现[[http://blog.csdn.net/xuanyun/article/details/1331872][此帖]]，讲得很详细，看来对求值模型还是理解不够，但关键是，racket
   解释器在实验练习1.5时明明是陷入死循环了，说明是应用序才对，但这里又工作得好好的，真让人
   搞不懂。。

** 练习1.7

   另一个 =good-enough?= 函数：
   : (define (good-enough? guess x)
   :   (< (/ (abs (- (improve guess x) guess)) guess) 0.00001))
   这个函数不是用绝对误差来作比较，而是用两次guess的变化率来比较，这在处理很小的数时会比较
   有用，比方说小数0.0000000001这种，但在处理大数时，反而会增加误差，因为计算变化率的分母
   很大，导致分子很大时依然能满足要求，所以在处理大数时不如先前版本的绝对误差精确。

** 练习1.8

   牛顿法解立方根：
   : (define (3sqrt guess x)
   :   (if (good-enough? guess x)
   :       guess
   :       (3sqrt (improve guess x) x)))
   :
   : (define (improve guess x)
   :   (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))
   :
   : (define (good-enough? guess x)
   :   (< (/ (abs (- (improve guess x) guess)) guess) 0.00001))

** 线性递归和迭代

   作为一个递归过程，但其计算过程可能会是递归的，也可能是迭代的。以阶乘计算为例：

   : ;; 第一种定义
   : (define (factorial n)
   :   (if (= n 1)
   :       1
   :       (* n (factorial (- n 1)))))

   : ;; 第二种定义
   : (define (factorial n)
   :   (define (fact-iter result counter)
   :     (if (> counter n)
   :         result
   :         (fact-iter (* result counter) (+ counter 1))))
   :   (fact-iter 1 1))

   毫无疑问两种定义都使用了递归过程，但两者有些不同：第一种在计算时会导致 =factorial= 自
   身的展开，而且用于计算的n越大，展开的层数越多；第二种在计算时，只需要维护 =result= 以
   及 =counter= 两个变量即可。

   在上面的例子中，第一种定义就是递归计算过程，第二种则是迭代计算过程。由于两者都是线性的，
   所以都是线性过程。（所谓线性是指，第一种的展开长度对于n是线性增长的；第二种的计算步骤对
   于n是线性增长的）

** 练习1.9

   : (inc (+ 3 5))
   : (inc (inc (+ 2 5)))
   : (inc (inc (inc (+ 1 5))))
   : (inc (inc (inc (inc (+ 0 5)))))
   : (inc (inc (inc (inc 5))))
   : (inc (inc (inc 6)))
   : (inc (inc 7))
   : (inc 8)
   : 9
   这是一个递归计算过程

   : (+ 3 6)
   : (+ 2 7)
   : (+ 1 8)
   : (+ 0 9)
   : 9
   这是一个迭代计算过程

** 练习1.10

   : (A 1 10) => 1024
   : (A 2 4)  => 65536
   : (A 3 3)  => 65536

   : f(n) = 2n
   : g(n) = 2^n
   : h(n) = 2^h(n-1)

** 练习1.11

   n < 3, f(n) = n; n >= 3, f(n) = f(n-1) + 2f(n-2) + 3f(n-3)

   递归过程：

   : (define (f n)
   :   (cond ((< n 3) n)
   :         (else (+ (f (- n 1))
   :                  (* 2 (f (- n 2)))
   :                  (* 3 (f (- n 3)))))))

   迭代过程：

   a = f(2) = 2, b = f(1) = 1, c = f(0) = 0
   a <= a + 2b + 3c
   b <= a
   c <= b

   : (define (f2 n)
   :   (f2-iter 2 1 0 n))
   :
   : (define (f2-iter a b c count)
   :   (if (= count 0)
   :       c
   :       (f2-iter (+ a (* 2 b) (* 3 c)) a b (- count 1))))

** 练习1.12

   杨辉三角的规律：f(n, 1) = f(n, n) = 1, f(n, m) = f(n-1, m-1) + f(n-1, m), 1 < m < n

   : (define (pascal-triangle n m)
   :   (if (or (= m 1) (= m n))
   :       1
   :       (+ (pascal-triangle (- n 1) (- m 1))
   :          (pascal-triangle (- n 1) m))))

** 练习1.13

   +暂时跳过，现在手头只有一台电脑，草稿纸和笔都没有，无法证明。。+

   整个计算过程涉及到一些数学符号，如果只用文本格式写会很蛋疼，于是，只写个思路：

   1. 按提示，证明 =Fib(n) = (φ^n - ψ^n) / √5= ，其中 =φ = (1 + √5) / 2= ， =ψ = (1 - √5) / 2= ，
      证明过程比较简单，根据数学归纳法和Fib(n)的定义即可。

   2. 之后，要证明Fib(n)是最接近φ^n/√5的整数，只需要证明 =|Fib(n) - φ^n/√5| ≤ 0.5= 即
      可。经过化简，需要证明的不等式变成 =|ψ^n / √5| ≤ 0.5= 。

   3. 经过观察， =|ψ^n / √5|= 实际上是趋于0的极限，所以只需要证明两点即可：

      1. =|ψ^n / √5| ≤ |ψ^(n-1) / √5|=
      2. =|ψ^0 / √5| ≤ 0.5=

      这两点都是比较好证明的。于是再反推回到第二步，就证明了Fib(n)是离φ^n/√5最近的整数。

** 练习1.14

   *再略过。。手头没有笔和纸，泪流满面。。*

** 练习1.15

   a) 这个问题一时半会儿不知道如何作答，就直接暴力地在函数 =p(x)= 的定义中加了一个打印函数
      来打印x以确定被调用了几次，结果显示， =(sine 12.15)= 调用了5次 =p(x)= 函数。

   b) 对 =(sine a)= 进行展开，第一次后a变成a/3，第二次变成a/9，所以，在n次之后，a变成了
      a除以3的n次方。空间和步数是正比于展开次数n的，所以，n关于a的阶就是空间和步数关于a的
      阶。展开的终止条件是 =a / 3^n ≤ 0.1= ，可以求出 =n ≥ log3(10a)= ，即n会大于
      等于以3为底10a的对数。所以空间和步数关于a的增长阶是对数的。

** 练习1.16

   题目要求：1.只能用迭代，不能递归；2.增长的阶是对数级。

   被这个题的提示给坑到了。。因为提示说维持一个附加变量a来保存计算值，于是我就按提示构造了
   一个状态变量a，打算用来保存每次迭代的计算值，但经过演算发现必须在第一步迭代将a从1直接给
   过渡到b^(n/2)，不然后面的迭代没法继续，但这肯定是不可能的。。

   无奈，去网上搜了一下，当我看到下面这两个等式的时候，我瞬间就明白了：

   1. n为偶数时：a(b^2)^(n/2) = ab^n
   2. n为奇数时：ab*b^(n-1) = ab^n

   按上面的等式写出迭代过程：

   : n为偶数时：
   : a <= a
   : b <= b^2
   : n <= n / 2
   :
   : n为奇数时：
   : a <= a * b
   : b <= b
   : n <= n - 1

   于是，解答如下：

   : (define (fast-expt b n)
   :   (fast-expt-iter 1 b n))
   :
   : (define (fast-expt-iter a b n)
   :   (cond ((= n 0) a)
   :         ((even? n) (fast-expt-iter a (* b b) (/ n 2)))
   :         (else (fast-expt-iter (* a b) b (- n 1)))))
   :
   : (define (even? n)
   :   (= (remainder n 2) 0))

   这明明是a和b共同保存中间值，以2^10为例，10 => 5 => 4 => 2 => 1 => 0，大多时候a都在打
   酱油，而b才是保存中间值的主力。。

** 练习1.17

   : (define (my* a b)
   :   (cond ((= b 0) 0)
   :         ((even? b) (my* (double a) (halve b)))
   :         (else (+ a (my* a (- b 1))))))
   :
   : (define (double a)
   :   (+ a a))
   :
   : (define (halve a)
   :   (/ a 2))

** 练习1.18

   有了1.16的基础，再来这道题就好多了，这题的难点是构造类似1.16中的ab^n。和1.16不同，这里
   的构造等式如下（状态变量定义为s）：

   1. b为偶数：s + ab = s + a*2 * b/2
   2. b为奇数：s + ab = (s + a) + a * (b - 1)

   于是，有如下解：

   : (define (my* a b)
   :   (my*-iter 0 a b))
   :
   : (define (my*-iter s a b)
   :   (cond ((= b 0) s)
   :         ((even? b) (my*-iter s (double a) (halve b)))
   :         (else (my*-iter (+ s a) a (- b 1)))))

** 练习1.19

   这个题是要求p'和q'，根据T^2 = T'，可以得到两个关于p'和q'的方程，联立方程可得解。

   这两个二元一次方程本身不难，但因为项太多，还有平方，所以如果打字打出来会很蛋疼，所以就不
   打了，最后解出的结果是：

   : p' = p^2 + q^2
   : q' = q^2 + 2pq

   吐槽：外国人真尼玛牛，一个特例斐波那契数列，能想到通用的T变换，而且，还尼玛T^2 = T'。。

** 练习1.20

   个人觉得这个题的水平略低，因为只是按照定义对过程调用进行展开而已。关键是，如果你展开的内
   容少一点也可以接受，但是 =(gcd 206 40)= 的正规序展开内容太多了，我写了几层，就写不下去
   了。。最后看了[[http://www.billthelizard.com/2010/01/sicp-exercise-120-gcd.html][这里]]的详细展开内容，那哥们真是耐得住。。其实题目的意思大概是想让我们对这两
   种展开方式有一个比较深刻的理解，但这样大量的重复性工作，显得没有必要，所以我没有耐得住寂
   寞展开到最后。。从那哥们展开的结果来看，最后的答案是18和4。

** 练习1.21

   把书中的的 =smallest-divisor= 及相关定义照执行一遍就行了，结果如下：

   : (smallest-divisor 199)    => 199
   : (smallest-divisor 1999)   => 1999
   : (smallest-divisor 19999)  => 7

   PS：SICP中文翻译中错误很多啊，比方说上面跟 =smallest-divisor= 相关的 =divides?= 定义，其
   中对 =remainder= 过程的调用就把参数a和b写反了，坑爹。。页脚的注释d/n应该是n/d。。

** 练习1.22
