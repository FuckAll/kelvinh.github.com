<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>SICP学习笔记和习题解答 - Kelvin的胡言乱语</title>
    <meta charset="utf-8" />
    <meta name="author" content="Kelvin Hu" />
    <meta name="description" content="learning notes of book Structure and Interpretation of Computer Programs" />
    <meta name="keywords" content="sicp, scheme" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
  </head>
  <body class="container">
    <div> 
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">Kelvin的胡言乱语</a></h1>
        <p>==============&gt; 重剑无锋，大巧不工。</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/wiki/">Wiki</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/kelvinh">GitHub</a></li>
          <li><a href="https://google.com/search?q=site:kelvinh.github.io">Search</a></li>
        </ul>
      </header>
    </div>
    <div> 
      <div class="post">
        <h1>SICP学习笔记和习题解答</h1>
        <p>
这里记录了我在学习SICP的过程中的一点笔记，以及作业解答，现在还正在学习中。。（因为作业太多了，读起来真慢。。）
</p>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">构造过程抽象</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">求值模型</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>正则序求值：先将复合式代入实际参数，再逐渐展开，直到得到一个只包含基本运算符的表达式，再对其进行求值。（完全展开而后归约）
</li>

<li>应用序求值：对于复合型表达式，将能进行计算的一些子表达式求值，再对其进行展开，再求值能够进行计算的子表达式，直到求出最终结果。（展开一层归约一层）
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">练习1.2</h3>
<div class="outline-text-3" id="text-1-2">
<pre class="example">
(/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))
</pre>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">练习1.3</h3>
<div class="outline-text-3" id="text-1-3">
<pre class="example">
the answer below is wrong!!!
(define (sum-of-max-two a b c)
    (cond ((&lt; a b) (if (&lt; a c) (+ b c) (+ a b)))
          (else (if (&lt; b c) (+ a c) (+ a b)))))
</pre>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">练习1.5</h3>
<div class="outline-text-3" id="text-1-4">
<p>
初看到 <code>(define (p) (p))</code> 这样的定义吓了我一跳，细看其实是一个递归函数的定义，但由没有退出条件，所以一旦有 <code>(p)</code> 这样的调用，程序将陷入死循环。
</p>

<p>
再看 <code>(test 0 (p))</code> ，如果是正则序，那么会完全展开再求值，于是会有如下过程：
</p>

<pre class="example">
1. (if (= 0 0) 0 (p))
2. (if #t 0 (p))
3. return value, 0
</pre>

<p>
如果是应用序，则会先求值 <code>(p)</code> ，于是程序陷入死循环。
</p>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">练习1.6</h3>
<div class="outline-text-3" id="text-1-5">
<p>
这个题目看了半天，大概猜到是跟求值模型相关的，但在解释器racket上试，和使用原始版本的if结果一模一样。。
</p>

<p>
于是，无奈Google之，发现<a href="http://blog.csdn.net/xuanyun/article/details/1331872">此帖</a>，讲得很详细，看来对求值模型还是理解不够，但关键是，racket解释器在实验练习1.5时明明是陷入死循环了，说明是应用序才对，但这里又工作得好好的，真让人搞不懂。。
</p>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">练习1.7</h3>
<div class="outline-text-3" id="text-1-6">
<p>
另一个 <code>good-enough?</code> 函数：
</p>

<pre class="example">
(define (good-enough? guess x)
  (&lt; (/ (abs (- (improve guess x) guess)) guess) 0.00001))
</pre>

<p>
这个函数不是用绝对误差来作比较，而是用两次guess的变化率来比较，这在处理很小的数时会比较有用，比方说小数0.0000000001这种，但在处理大数时，反而会增加误差，因为计算变化率的分母很大，导致分子很大时依然能满足要求，所以在处理大数时不如先前版本的绝对误差精确。
</p>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">练习1.8</h3>
<div class="outline-text-3" id="text-1-7">
<p>
牛顿法解立方根：
</p>

<pre class="example">
(define (3sqrt guess x)
  (if (good-enough? guess x)
      guess
      (3sqrt (improve guess x) x)))

(define (improve guess x)
  (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))

(define (good-enough? guess x)
  (&lt; (/ (abs (- (improve guess x) guess)) guess) 0.00001))
</pre>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">线性递归和迭代</h3>
<div class="outline-text-3" id="text-1-8">
<p>
作为一个递归过程，但其计算过程可能会是递归的，也可能是迭代的。以阶乘计算为例：
</p>

<pre class="example">
;; 第一种定义
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
</pre>

<pre class="example">
;; 第二种定义
(define (factorial n)
  (define (fact-iter result counter)
    (if (&gt; counter n)
        result
        (fact-iter (* result counter) (+ counter 1))))
  (fact-iter 1 1))
</pre>

<p>
毫无疑问两种定义都使用了递归过程，但两者有些不同：第一种在计算时会导致 <code>factorial</code> 自身的展开，而且用于计算的n越大，展开的层数越多；第二种在计算时，只需要维护 <code>result</code> 以及 <code>counter</code> 两个变量即可。
</p>

<p>
在上面的例子中，第一种定义就是递归计算过程，第二种则是迭代计算过程。由于两者都是线性的，所以都是线性过程。（所谓线性是指，第一种的展开长度对于n是线性增长的；第二种的计算步骤对于n是线性增长的）
</p>
</div>
</div>
<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">练习1.9</h3>
<div class="outline-text-3" id="text-1-9">
<pre class="example">
(inc (+ 3 5))
(inc (inc (+ 2 5)))
(inc (inc (inc (+ 1 5))))
(inc (inc (inc (inc (+ 0 5)))))
(inc (inc (inc (inc 5))))
(inc (inc (inc 6)))
(inc (inc 7))
(inc 8)
9
</pre>

<p>
这是一个递归计算过程
</p>

<pre class="example">
(+ 3 6)
(+ 2 7)
(+ 1 8)
(+ 0 9)
9
</pre>

<p>
这是一个迭代计算过程
</p>
</div>
</div>
<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">练习1.10</h3>
<div class="outline-text-3" id="text-1-10">
<pre class="example">
(A 1 10) =&gt; 1024
(A 2 4)  =&gt; 65536
(A 3 3)  =&gt; 65536
</pre>

<pre class="example">
f(n) = 2n
g(n) = 2^n
h(n) = 2^h(n-1)
</pre>
</div>
</div>
<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">练习1.11</h3>
<div class="outline-text-3" id="text-1-11">
<p>
n &lt; 3, f(n) = n; n &gt;= 3, f(n) = f(n-1) + 2f(n-2) + 3f(n-3)
</p>

<p>
递归过程：
</p>

<pre class="example">
(define (f n)
  (cond ((&lt; n 3) n)
        (else (+ (f (- n 1))
                 (* 2 (f (- n 2)))
                 (* 3 (f (- n 3)))))))
</pre>

<p>
迭代过程：
</p>

<p>
a = f(2) = 2, b = f(1) = 1, c = f(0) = 0
a &lt;= a + 2b + 3c
b &lt;= a
c &lt;= b
</p>

<pre class="example">
(define (f2 n)
  (f2-iter 2 1 0 n))

(define (f2-iter a b c count)
  (if (= count 0)
      c
      (f2-iter (+ a (* 2 b) (* 3 c)) a b (- count 1))))
</pre>
</div>
</div>
<div id="outline-container-sec-1-12" class="outline-3">
<h3 id="sec-1-12">练习1.12</h3>
<div class="outline-text-3" id="text-1-12">
<p>
杨辉三角的规律：f(n, 1) = f(n, n) = 1, f(n, m) = f(n-1, m-1) + f(n-1, m), 1 &lt; m &lt; n
</p>

<pre class="example">
(define (pascal-triangle n m)
  (if (or (= m 1) (= m n))
      1
      (+ (pascal-triangle (- n 1) (- m 1))
         (pascal-triangle (- n 1) m))))
</pre>
</div>
</div>
<div id="outline-container-sec-1-13" class="outline-3">
<h3 id="sec-1-13">练习1.13</h3>
<div class="outline-text-3" id="text-1-13">
<p>
<del>暂时跳过，现在手头只有一台电脑，草稿纸和笔都没有，无法证明。。</del>
</p>

<p>
整个计算过程涉及到一些数学符号，如果只用文本格式写会很蛋疼，于是，只写个思路：
</p>

<ol class="org-ol">
<li>按提示，证明 <code>Fib(n) = (φ^n - ψ^n) / √5</code> ，其中 <code>φ = (1 + √5) / 2</code> ， <code>ψ = (1 - √5) / 2</code> ，证明过程比较简单，根据数学归纳法和Fib(n)的定义即可。
</li>

<li>之后，要证明Fib(n)是最接近φ^n/√5的整数，只需要证明 <code>|Fib(n) - φ^n/√5| ≤ 0.5</code> 即可。经过化简，需要证明的不等式变成 <code>|ψ^n / √5| ≤ 0.5</code> 。
</li>

<li>经过观察， <code>|ψ^n / √5|</code> 实际上是趋于0的极限，所以只需要证明两点即可：

<ol class="org-ol">
<li><code>|ψ^n / √5| ≤ |ψ^(n-1) / √5|</code>
</li>
<li><code>|ψ^0 / √5| ≤ 0.5</code>
</li>
</ol>
<p>
这两点都是比较好证明的。于是再反推回到第二步，就证明了Fib(n)是离φ^n/√5最近的整数。
</p>
</li>
</ol>
</div>
</div>
<div id="outline-container-sec-1-14" class="outline-3">
<h3 id="sec-1-14">练习1.14</h3>
<div class="outline-text-3" id="text-1-14">
<p>
<b>再略过。。手头没有笔和纸，泪流满面。。</b>
</p>
</div>
</div>
<div id="outline-container-sec-1-15" class="outline-3">
<h3 id="sec-1-15">练习1.15</h3>
<div class="outline-text-3" id="text-1-15">
<p>
a) 这个问题一时半会儿不知道如何作答，就直接暴力地在函数 <code>p(x)</code> 的定义中加了一个打印函数来打印x以确定被调用了几次，结果显示， <code>(sine 12.15)</code> 调用了5次 <code>p(x)</code> 函数。
</p>

<p>
b) 对 <code>(sine a)</code> 进行展开，第一次后a变成a/3，第二次变成a/9，所以，在n次之后，a变成了a除以3的n次方。空间和步数是正比于展开次数n的，所以，n关于a的阶就是空间和步数关于a的阶。展开的终止条件是 <code>a / 3^n ≤ 0.1</code> ，可以求出 <code>n ≥ log3(10a)</code> ，即n会大于等于以3为底10a的对数。所以空间和步数关于a的增长阶是对数的。
</p>
</div>
</div>
<div id="outline-container-sec-1-16" class="outline-3">
<h3 id="sec-1-16">练习1.16</h3>
<div class="outline-text-3" id="text-1-16">
<p>
题目要求：1.只能用迭代，不能递归；2.增长的阶是对数级。
</p>

<p>
被这个题的提示给坑到了。。因为提示说维持一个附加变量a来保存计算值，于是我就按提示构造了一个状态变量a，打算用来保存每次迭代的计算值，但经过演算发现必须在第一步迭代将a从1直接给过渡到b^(n/2)，不然后面的迭代没法继续，但这肯定是不可能的。。
</p>

<p>
无奈，去网上搜了一下，当我看到下面这两个等式的时候，我瞬间就明白了：
</p>

<ol class="org-ol">
<li>n为偶数时：a(b^2)^(n/2) = ab^n
</li>
<li>n为奇数时：ab*b^(n-1) = ab^n
</li>
</ol>

<p>
按上面的等式写出迭代过程：
</p>

<pre class="example">
n为偶数时：
a &lt;= a
b &lt;= b^2
n &lt;= n / 2

n为奇数时：
a &lt;= a * b
b &lt;= b
n &lt;= n - 1
</pre>

<p>
于是，解答如下：
</p>

<pre class="example">
(define (fast-expt b n)
  (fast-expt-iter 1 b n))

(define (fast-expt-iter a b n)
  (cond ((= n 0) a)
        ((even? n) (fast-expt-iter a (* b b) (/ n 2)))
        (else (fast-expt-iter (* a b) b (- n 1)))))

(define (even? n)
  (= (remainder n 2) 0))
</pre>

<p>
这明明是a和b共同保存中间值，以2^10为例，10 =&gt; 5 =&gt; 4 =&gt; 2 =&gt; 1 =&gt; 0，大多时候a都在打酱油，而b才是保存中间值的主力。。
</p>
</div>
</div>
<div id="outline-container-sec-1-17" class="outline-3">
<h3 id="sec-1-17">练习1.17</h3>
<div class="outline-text-3" id="text-1-17">
<pre class="example">
(define (my* a b)
  (cond ((= b 0) 0)
        ((even? b) (my* (double a) (halve b)))
        (else (+ a (my* a (- b 1))))))

(define (double a)
  (+ a a))

(define (halve a)
  (/ a 2))
</pre>
</div>
</div>
<div id="outline-container-sec-1-18" class="outline-3">
<h3 id="sec-1-18">练习1.18</h3>
<div class="outline-text-3" id="text-1-18">
<p>
有了1.16的基础，再来这道题就好多了，这题的难点是构造类似1.16中的ab^n。和1.16不同，这里的构造等式如下（状态变量定义为s）：
</p>

<ol class="org-ol">
<li>b为偶数：s + ab = s + a*2 * b/2
</li>
<li>b为奇数：s + ab = (s + a) + a * (b - 1)
</li>
</ol>

<p>
于是，有如下解：
</p>

<pre class="example">
(define (my* a b)
  (my*-iter 0 a b))

(define (my*-iter s a b)
  (cond ((= b 0) s)
        ((even? b) (my*-iter s (double a) (halve b)))
        (else (my*-iter (+ s a) a (- b 1)))))
</pre>
</div>
</div>
<div id="outline-container-sec-1-19" class="outline-3">
<h3 id="sec-1-19">练习1.19</h3>
<div class="outline-text-3" id="text-1-19">
<p>
这个题是要求p'和q'，根据T^2 = T'，可以得到两个关于p'和q'的方程，联立方程可得解。
</p>

<p>
这两个二元一次方程本身不难，但因为项太多，还有平方，所以如果打字打出来会很蛋疼，所以就不打了，最后解出的结果是：
</p>

<pre class="example">
p' = p^2 + q^2
q' = q^2 + 2pq
</pre>

<p>
吐槽：外国人真尼玛牛，一个特例斐波那契数列，能想到通用的T变换，而且，还尼玛T^2 = T'。。
</p>
</div>
</div>
<div id="outline-container-sec-1-20" class="outline-3">
<h3 id="sec-1-20">练习1.20</h3>
<div class="outline-text-3" id="text-1-20">
<p>
个人觉得这个题的水平略低，因为只是按照定义对过程调用进行展开而已。关键是，如果你展开的内容少一点也可以接受，但是 <code>(gcd 206 40)</code> 的正规序展开内容太多了，我写了几层，就写不下去了。。最后看了<a href="http://www.billthelizard.com/2010/01/sicp-exercise-120-gcd.html">这里</a>的详细展开内容，那哥们真是耐得住。。其实题目的意思大概是想让我们对这两种展开方式有一个比较深刻的理解，但这样大量的重复性工作，显得没有必要，所以我没有耐得住寂寞展开到最后。。从那哥们展开的结果来看，最后的答案是18和4。
</p>
</div>
</div>
<div id="outline-container-sec-1-21" class="outline-3">
<h3 id="sec-1-21">练习1.21</h3>
<div class="outline-text-3" id="text-1-21">
<p>
把书中的的 <code>smallest-divisor</code> 及相关定义照执行一遍就行了，结果如下：
</p>

<pre class="example">
(smallest-divisor 199)    =&gt; 199
(smallest-divisor 1999)   =&gt; 1999
(smallest-divisor 19999)  =&gt; 7
</pre>

<p>
PS：SICP中文翻译中错误很多啊，比方说上面跟 <code>smallest-divisor</code> 相关的 <code>divides?</code> 定义，其中对 <code>remainder</code> 过程的调用就把参数a和b写反了，坑爹。。页脚的注释d/n应该是n/d。。
</p>
</div>
</div>
<div id="outline-container-sec-1-22" class="outline-3">
<h3 id="sec-1-22">练习1.22</h3>
<div class="outline-text-3" id="text-1-22">
<p>
我使用的Scheme实现是Racket，这个实现并没有包含如题目中所说的 <code>runtime</code> ，于是我Google了一下，发现有一个过程叫 <code>current-inexact-milliseconds</code> 可以达到要求，于是就用它代替了 <code>runtime</code> 。
</p>

<p>
这个题目的实现代码如下：
</p>

<pre class="example">
(define (timed-prime-test n)
  (newline)
  (display n)
  (start-prime-test n (current-inexact-milliseconds)))

(define (start-prime-test n start-time)
  (if (prime? n)
      (report-time (- (current-inexact-milliseconds) start-time))
      #f))  ;; 这里因为Racket实现不允许if只有一个分支，所以用#f来表示另一个分支

(define (report-time elapsed-time)
  (display " *** ")
  (display elapsed-time))

(define (search-for-primes start count)
  (cond ((= count 0) (newline))
        ((timed-prime-test start) (search-for-primes (next-odd start) (- count 1)))
        (else (search-for-primes (next-odd start) count))))

(define (next-odd n)
  (if (= (remainder n 2) 0)
      (+ 1 n)
      (+ 2 n)))
</pre>

<p>
测试了几组数据，得到以下结果（不是奇数的行已删去）：
</p>

<pre class="example">
100000000003 *** 24.06689453125
100000000019 *** 14.223876953125
100000000057 *** 15.403076171875
&gt;
1000000000039 *** 49.025146484375
1000000000061 *** 48.720947265625
1000000000063 *** 47.57080078125
&gt;
10000000000037 *** 154.43701171875
10000000000051 *** 143.823974609375
10000000000099 *** 147.25390625
</pre>

<p>
取平均值除了一下，时间比值为2.706和3.066，这两个离√10还差得比较多，不过可能是受CPU，系统环境的影响，随机性较强，不过比值应该是√10这一点还是很明确的。
</p>
</div>
</div>
<div id="outline-container-sec-1-23" class="outline-3">
<h3 id="sec-1-23">练习1.23</h3>
<div class="outline-text-3" id="text-1-23">
<pre class="example">
(define (next n)
  (if (= n 2)
      3
      (+ n 2)))

(define (find-divisor n test)
  (cond ((&gt; (* test test) n) n)
        ((divides? n test) test)
        (else (find-divisor n (next test)))))
</pre>

<p>
得到结果如下（取了三组和1.22中对应的值）：
</p>

<pre class="example">
100000000003 *** 14.049072265625
100000000019 *** 10.261962890625
100000000057 *** 9.14697265625
&gt;
1000000000039 *** 40.97705078125
1000000000061 *** 30.837890625
1000000000063 *** 31.4189453125
&gt;
10000000000037 *** 103.964111328125
10000000000051 *** 102.067138671875
10000000000099 *** 94.930908203125
</pre>

<p>
分别计算平均消耗时间比值，得到三个值：1.61，1.41，1.48，这几个值是明显是小于2的。可能虽然步数是少了一半，但是在运行过程中的一些其它消耗，导致了时间比值小于2。
</p>

<p>
然后我又试了一下，证明这多出来的时间消耗是来自 <code>next</code> 过程调用，将 <code>find-divisor</code> 以及 <code>smallest-divisor</code> 过程进行重定义为以下形式：
</p>

<pre class="example">
(define (find-divisor n test)
  (cond ((&gt; (* test test) n) n)
        ((divides? n test) test)
        (else (find-divisor n (+ test 2))))) ;; 直接加2，不再调用next过程

(define (smallest-divisor n)
  (find-divisor n 3)) ;; 直接从3开始
</pre>

<p>
结果如下：
</p>

<pre class="example">
100000000003 *** 13.234130859375
100000000019 *** 8.0458984375
100000000057 *** 7.89599609375
&gt;
1000000000039 *** 28.672119140625
1000000000061 *** 25.3388671875
1000000000063 *** 25.071044921875
&gt;
10000000000037 *** 78.4560546875
10000000000051 *** 78.115966796875
10000000000099 *** 71.85498046875
</pre>

<p>
可以看到，这里的时间消耗确实是比1.22中减半了。
</p>
</div>
</div>
<div id="outline-container-sec-1-24" class="outline-3">
<h3 id="sec-1-24">练习1.24</h3>
<div class="outline-text-3" id="text-1-24">
<p>
这个练习，将 <code>start-prime-test</code> 中的 <code>prime?</code> 换成 <code>fast-prime?</code> 即可：
</p>

<pre class="example">
(define (start-prime-test n start-time)
  (if (fast-prime? n 3)  ;; 测试的次数取3
      (report-time (- (current-inexact-milliseconds) start-time))
      #f))
</pre>

<p>
然后进行测试，得到以下结果（最高只能到10的9次方，因为再高的话，超过了int型的最大值，这时 <code>random</code> 函数会报错）：
</p>

<pre class="example">
1009 *** 0.014892578125
1013 *** 0.01611328125
1019 *** 0.015869140625
&gt;
10007 *** 0.02099609375
10009 *** 0.02099609375
10037 *** 0.02001953125
&gt;
100003 *** 0.02490234375
100019 *** 0.02392578125
100043 *** 0.02392578125
&gt;
1000003 *** 0.028076171875
1000033 *** 0.028076171875
1000037 *** 0.029052734375
&gt;
10000019 *** 0.032958984375
10000079 *** 0.033203125
10000103 *** 0.032958984375
&gt;
100000007 *** 0.0380859375
100000037 *** 0.0380859375
100000039 *** 0.0380859375
&gt;
1000000007 *** 0.041015625
1000000009 *** 0.0419921875
1000000021 *** 0.0419921875
</pre>

<p>
增长速度是O(log n)，所以10^6附近应该是10^3附近所消耗时间的两倍，10^9是三倍：从上面的结果来看，10^6次方的数据比较接近（0.028/0.014），但10^9则要小了不少，只有大概2.67倍左右；10^8应该是10^4的两倍，这个数据也还比较接近（0.038/0.020）。
</p>
</div>
</div>
<div id="outline-container-sec-1-25" class="outline-3">
<h3 id="sec-1-25">练习1.25</h3>
<div class="outline-text-3" id="text-1-25">
<p>
其实这个问题的答案在前面的脚注46中就说了：
</p>

<blockquote>
<p>
这种技术非常有用，因为它意味着我们的计算中不需要去处理比m大很多的数（请与练习1.25比较）。
</p>
</blockquote>

<p>
原来的 <code>expmod</code> 函数是利用了以下的等式：
</p>

<pre class="example">
(x * y) % m = [(x % m) * (y % m)] % m
</pre>

<p>
这样，如果 <code>x*y</code> 的值很大的话，可以分解成两个小于m的数再取模，这样计算起来就要容易很多。
</p>

<p>
而1.25中的 <code>expmod</code> 的定义也是没问题的：先算出乘方值，再取模。但是需要注意的是，这个乘方值可能很大，这样再求模，可能就会很慢，没有办法和原来版本的高效性相提并论。
</p>
</div>
</div>
<div id="outline-container-sec-1-26" class="outline-3">
<h3 id="sec-1-26">练习1.26</h3>
<div class="outline-text-3" id="text-1-26">
<p>
这个题还比较好理解，在使用 <code>square</code> 的时候，只需要在 <code>expmod</code> 内部执行一次递归调用，但直接使用乘法的话，会执行两次递归调用，情况如下：
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col class="right"/>

<col class="left"/>

<col class="left"/>
</colgroup>
<thead>
<tr>
<th scope="col" class="right">次数</th>
<th scope="col" class="left">递归情况(square)</th>
<th scope="col" class="left">递归情况(*)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="right">1</td>
<td class="left">n</td>
<td class="left">n</td>
</tr>

<tr>
<td class="right">2</td>
<td class="left">n/2</td>
<td class="left">n/2 * n/2</td>
</tr>

<tr>
<td class="right">3</td>
<td class="left">n/4</td>
<td class="left">n/4 * n/4 * n/4 * n/4</td>
</tr>

<tr>
<td class="right">&#x2026;</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
注：上表没有考虑 <code>n-1</code> 的情况，因为 <code>n-1</code> 作为常数级的衰减（请原谅，我自己发明了“衰减”这个词），和指数级衰减比起来可以忽略。
</p>

<p>
可以看到，使用 <code>square</code> 的情况是指数级衰减，所以最终是Θ(log n)；直接使用乘法虽然也是指数级衰减，但是衰减的同时，递归调用数却在指数级增加，刚好和衰减抵消，于是就是Θ(n)。
</p>
</div>
</div>
<div id="outline-container-sec-1-27" class="outline-3">
<h3 id="sec-1-27">练习1.27</h3>
<div class="outline-text-3" id="text-1-27">
<p>
这个题目比较简单，定义的两个函数如下：
</p>

<pre class="example">
(define (carmichael-check n a)
  (cond ((not (= (expmod a n n) a)) false)
        ((&gt; a 1) (carmichael-check n (- a 1)))
        (else true)))

(define (carmichael-test n)
  (carmichael-check n (- n 1)))
</pre>

<p>
需要测试Carmichael数的时候，执行 <code>carmichael-test</code> 即可。这个测试有一点缺陷就是，不能把真正的质数和Carmichael数分开，不过题目是要求验证Carmichael数，而并不是求Carmichael数，所以这点缺陷也不算是缺陷。
</p>
</div>
</div>
<div id="outline-container-sec-1-28" class="outline-3">
<h3 id="sec-1-28">练习1.28</h3>
<div class="outline-text-3" id="text-1-28">
<p>
这个题目是费马测试的一个变形，因为费马测试会被Carmichael数骗，所以这个Miller-Rabin检查增强了限制，Carmichael数也通不过检查。增强的条件是：如果大于1小于n - 1的一个数的平方取模n等于1，则n不是素数。这样，需要我们将费马测试中的 <code>expmod</code> 函数加以改进，所有相关的过程如下：
</p>

<pre class="example">
(define (determine-result a n)
  (cond ((and (not (= a 1))
              (not (= a (- n 1)))
              (= (remainder (square a) n) 1)) 0)
        (else (remainder (square a) n))))

(define (expmod base exp m)
  (cond ((= exp 0) 1)
        ((even? exp)
         (determine-result (expmod base (/ exp 2) m) m))
        (else (remainder (* base (expmod base (- exp 1) m)) m))))

(define (miller-rabin-test n)
  (define (try-it a)
    (= (expmod a (- n 1) n) 1))
  (try-it (+ 1 (random (- n 1)))))

(define (miller-rabin-prime? n times)
  (cond ((= times 0) true)
        ((miller-rabin-test n) (miller-rabin-prime? n (- times 1)))
        (else false)))
</pre>

<p>
再用 <code>miller-rabin-prime?</code> 检测素数的时候，就算连561，1105等Carmichael数也无处遁形了。
</p>
</div>
</div>
<div id="outline-container-sec-1-29" class="outline-3">
<h3 id="sec-1-29">练习1.29</h3>
<div class="outline-text-3" id="text-1-29">
<p>
定义两个过程如下：
</p>

<pre class="example">
(define (sum-simpson-rule f k n a b)
  (define (factor)
    (cond ((or (= k 0)
               (= k n)) 1)
          ((= (remainder k 2) 0) 2)
          (else 4)))
  (if (&gt; k n)
      0
      (+ (* (factor) (f (+ a (* k (/ (- b a) n)))))
         (sum-simpson-rule f (+ 1 k) n a b))))

(define (simpson-rule f n a b)
  (* (/ (/ (- b a) n) 3) (sum-simpson-rule f 0 n a b)))
</pre>

<p>
经过测试，这个辛普森规则准得过分，在测试 <code>cube</code> 函数在0到1之间的积分时，n都不用取到100或者1000，就算取成2，结果也是精确的1/4。。。
</p>
</div>
</div>
<div id="outline-container-sec-1-30" class="outline-3">
<h3 id="sec-1-30">练习1.30</h3>
<div class="outline-text-3" id="text-1-30">
<p>
采用迭代进行计算的 <code>sum</code> 过程如下：
</p>

<pre class="example">
(define (sum term a next b)
  (define (iter a result)
    (if (&gt; a b)
        result
        (iter (next a) (+ (term a) result))))
  (iter a 0))
</pre>
</div>
</div>
<div id="outline-container-sec-1-31" class="outline-3">
<h3 id="sec-1-31">练习1.31</h3>
<div class="outline-text-3" id="text-1-31">
<p>
递归的 <code>product</code> 过程：
</p>

<pre class="example">
(define (product term a next b)
  (if (&gt; a b)
      1
      (* (term a)
         (product term (next a) next b))))
</pre>

<p>
迭代的 <code>product</code> 过程：
</p>

<pre class="example">
(define (product term a next b)
  (define (iter a result)
    (if (&gt; a b)
        result
        (iter (next a) (* (term a) result))))
  (iter a 1))
</pre>

<p>
<code>factorial</code> 过程：
</p>

<pre class="example">
(define (factorial n)
  (product (lambda (a) a) 1 (lambda (a) (+ 1 a)) n))
</pre>

<p>
求圆周率PI的过程：
</p>

<pre class="example">
(define (cal-pi n)
  (* 2.0           ;; 使用2.0而不用2，是为了让结果展示为小数而不是分数
     (if (even? n) n (+ 1 n)) ;; 这个不可缺少，下面有解释
     (/
      (product (lambda (a) (square a))
               2
               (lambda (a) (+ 2 a))
               (if (even? n) n (+ 1 n)))
      (product (lambda (a) (square a))
               3
               (lambda (a) (+ 2 a))
               (if (even? n) (+ 1 n) (+ 2 n))))))
</pre>

<p>
书中给出的求PI公式比较tricky，将等式两边乘以2，就会发现形式比书中原来的形式要完美很多，上面的过程的基础正是乘以2后的等式。分别计算分子和分母，相除后，再乘以2，但要注意的是，这时的结果还不是圆周率，还需要乘以最后一个参加计算的分子值，为什么呢？因为我们最初为图方便（为了使用平方计算），把等式两边都乘以2，这样就硬生生把分子部分的序列给向后移了一位，所以要将原来被挤掉的分子最后一个参加计算的数字给补上。
</p>
</div>
</div>
<div id="outline-container-sec-1-32" class="outline-3">
<h3 id="sec-1-32">练习1.32</h3>
<div class="outline-text-3" id="text-1-32">
<p>
递归的 <code>accumulate</code> 过程：
</p>

<pre class="example">
(define (accumulate combiner null-value term a next b)
  (if (&gt; a b)
      null-value
      (combiner (term a)
                (accumulate combiner null-value term (next a) next b))))
</pre>

<p>
迭代的 <code>accumulate</code> 过程：
</p>

<pre class="example">
(define (accumulate combiner null-value term a next b)
  (define (iter a result)
    (if (&gt; a b)
        result
        (iter (next a) (combiner (term a) result))))
  (iter a null-value))
</pre>

<p>
利用 <code>accumulate</code> 进行重定义的 <code>sum</code> 和 <code>product</code> 过程：
</p>

<pre class="example">
(define (sum term a next b)
  (accumulate + 0 term a next b))

(define (product term a next b)
  (accumulate * 1 term a next b))
</pre>
</div>
</div>
<div id="outline-container-sec-1-33" class="outline-3">
<h3 id="sec-1-33">练习1.33</h3>
<div class="outline-text-3" id="text-1-33">
<p>
<code>filtered-accumulate</code> 过程以及根据其定义的求素数和、求互素正整数积的过程：
</p>

<pre class="example">
(define (filtered-accumulate combiner null-value term a next b filter)
  (if (or (&gt; a b) (not (filter a b)))
      null-value
      (combiner (term a)
                (filtered-accumulate combiner null-value term (next a) next b filter))))

(define (sum-prime a b)
  (filtered-accumulate + 0 (lambda (a) a) a (lambda (a) (+ 1 a)) b prime?))

(define (product-gcd-prime n)
  (filtered-accumulate * 1 (lambda (a) a) 1 (lambda (a) (+ 1 a)) n gcd-eq1?))
</pre>
</div>
</div>
<div id="outline-container-sec-1-34" class="outline-3">
<h3 id="sec-1-34">练习1.34</h3>
<div class="outline-text-3" id="text-1-34">
<p>
如果求值 <code>(f f)</code> ，展开的流程如下：
</p>

<pre class="example">
(f f) =&gt; (f 2) =&gt; (2 2)
</pre>

<p>
因为2不是一个过程名，所以出错。
</p>
</div>
</div>
<div id="outline-container-sec-1-35" class="outline-3">
<h3 id="sec-1-35">练习1.35</h3>
<div class="outline-text-3" id="text-1-35">
<p>
<code>x |-&gt; 1 + 1/x</code> 的不动点即要求满足 <code>x = 1 + 1/x</code> ，两边乘以x得到 <code>x^2 = x + 1</code> ，即黄金分割满足的方程。
</p>

<p>
通过 <code>fixed-point</code> 来计算黄金分割率：
</p>

<pre class="example">
(fixed-point (lambda (x) (+ 1 (/ 1 x))) 0.5)
</pre>
</div>
</div>
<div id="outline-container-sec-1-36" class="outline-3">
<h3 id="sec-1-36">练习1.36</h3>
<div class="outline-text-3" id="text-1-36">
<p>
修改后的 <code>fixed-point</code> 过程：
</p>

<pre class="example">
(define (fixed-point f first-guess)
  (define (close-enough? v1 v2)
    (&lt; (abs (- v1 v2)) 0.0000001))
  (define (try guess)
    (let ((next (f guess)))
      (display next)
      (newline)
      (if (close-enough? guess next)
          next
          (try next))))
  (try first-guess))
</pre>

<p>
不使用平均阻尼：
</p>

<pre class="example">
(fixed-point (lambda (x) (/ (log 1000) (log x))) 2)
</pre>

<p>
使用平均阻尼：
</p>

<pre class="example">
(fixed-point (lambda (x) (average x (/ (log 1000) (log x)))) 2)
</pre>

<p>
允许误差为10e-7的情况下，不使用平均阻尼需要46步，使用平均阻尼只需要13步。可见使用平均阻尼能大大减少必要的计算步数。
</p>
</div>
</div>
<div id="outline-container-sec-1-37" class="outline-3">
<h3 id="sec-1-37">练习1.37</h3>
<div class="outline-text-3" id="text-1-37">
<p>
递归的 <code>cont-frac</code> 过程：
</p>

<pre class="example">
(define (cont-frac n d k)
  (define (frac i)
    (if (&gt; i k)
        0
        (/ (n i)
           (+ (d i) (frac (+ 1 i))))))
  (frac 1))
</pre>

<p>
迭代的 <code>cont-frac</code> 过程：
</p>

<pre class="example">
(define (cont-frac n d k)
  (define (iter i result)
    (if (&lt; i 1)
        result
        (iter (- i 1)
              (/ (n i)
                 (+ (d i) result)))))
  (iter k 0))
</pre>

<p>
用下面的lambda过程来确定满足条件的k：
</p>

<pre class="example">
((lambda (k)
   (&lt; (abs (- (/ 1 (cont-frac (lambda (i) 1.0)
                              (lambda (i) 1.0)
                              k))
              1.61803401))
      0.0001))
 11)
</pre>

<p>
最后确定，k取11即可保证4位的十进制精度。
</p>
</div>
</div>
<div id="outline-container-sec-1-38" class="outline-3">
<h3 id="sec-1-38">练习1.38</h3>
<div class="outline-text-3" id="text-1-38">
<p>
这个题目最关键的是确定 <code>D(i)</code> 函数的值，观察规律，可以知道，序列中的3n项和3n+1项都是1，而3n+2项的值是2n+2，这里n是非负整数。所以，=D(i)= 相应的过程定义如下：
</p>

<pre class="example">
(define (d i)
  (cond ((or (= (remainder i 3) 0)
             (= (remainder i 3) 1)) 1)
        (else (/ (* 2 (+ 1 i)) 3))))
</pre>

<p>
用来求e的程序：
</p>

<pre class="example">
(+ 2
   (cont-frac (lambda (i) 1.0) d 100000))
</pre>
</div>
</div>
<div id="outline-container-sec-1-39" class="outline-3">
<h3 id="sec-1-39">练习1.39</h3>
<div class="outline-text-3" id="text-1-39">
<p>
<code>tan-cf</code> 过程如下：
</p>

<pre class="example">
(define (tan-cf x k)
  (define (n i)
    (if (= i 1) x (square x)))
  (define (d i)
    (- (* 2 i) 1))
  (define (cf i)
    (if (&gt; i k)
        0
        (/ (n i)
           (- (d i) (cf (+ 1 i))))))
  (cf 1))
</pre>
</div>
</div>
<div id="outline-container-sec-1-40" class="outline-3">
<h3 id="sec-1-40">练习1.40</h3>
<div class="outline-text-3" id="text-1-40">
<pre class="example">
(define (cubic a b c)
  (lambda (x)
    (+ (cube x)
       (* a (square x))
       (* b x)
       c)))
</pre>
</div>
</div>
<div id="outline-container-sec-1-41" class="outline-3">
<h3 id="sec-1-41">练习1.41</h3>
<div class="outline-text-3" id="text-1-41">
<p>
<code>double</code> 过程：
</p>

<pre class="example">
(define (double f)
  (lambda (x) (f (f x))))
</pre>

<p>
表达式的值是21，因为两次 <code>double</code> 调用就得到4层 <code>double</code> 嵌套的过程，再对 <code>inc</code> 作用，就会得到2的4次方，即16次 <code>inc</code> 过程的调用，所以结果是5 + 16 = 21。
</p>
</div>
</div>
<div id="outline-container-sec-1-42" class="outline-3">
<h3 id="sec-1-42">练习1.42</h3>
<div class="outline-text-3" id="text-1-42">
<pre class="example">
(define (compose f g)
  (lambda (x) (f (g x))))
</pre>
</div>
</div>
<div id="outline-container-sec-1-43" class="outline-3">
<h3 id="sec-1-43">练习1.43</h3>
<div class="outline-text-3" id="text-1-43">
<pre class="example">
(define (repeated f n)
  (if (&lt;= n 1)
      (lambda (x) (f x))
      ;(repeated (compose f f) (- n 1))
      (compose f (repeated f (- n 1)))))
</pre>

<p>
需要注意 <code>repeated</code> 和 <code>compose</code> 的调用顺序，如果先调用 <code>compose</code> 再调用 <code>repeated</code> （如代码中注释所示），那过程 <code>f</code> 会被重复2的n-1次方（注意是次方关系）；但是反之，则 <code>f</code> 就只会被重复n次，是加和关系。
</p>
</div>
</div>
<div id="outline-container-sec-1-44" class="outline-3">
<h3 id="sec-1-44">练习1.44</h3>
<div class="outline-text-3" id="text-1-44">
<p>
平滑过程 <code>smooth</code> ：
</p>

<pre class="example">
(define dx 0.0000000001)

(define (smooth f)
  (lambda (x) (/ (+ (f x) (f (- x dx)) (f (+ x dx))) 3)))
</pre>

<p>
n次平滑过程 <code>smooth-n</code> ：
</p>

<pre class="example">
(define (smooth-n f n)
  ((repeated smooth n) f))
</pre>
</div>
</div>
</div>

      </div>
    </div>
    <div> 
      <div class="post-meta">
        <span title="post date" class="post-info">2012-12-10</span>
        <span title="last modification date" class="post-info">2013-07-01</span>
        <span title="tags" class="post-info"><a href="/tags/sicp/">SICP</a>, <a href="/tags/scheme/">Scheme</a></span>
        <span title="author" class="post-info">Kelvin Hu</span>
      </div>
      <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-41088132-1']);
        _gaq.push(['_trackPageview']);
        (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      </script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.0.3)</p>
        <p> 
          Copyright &copy; 2012 - 2013 <a href="mailto:ini &lt;dot&gt; kelvin &lt;at&gt; gmail &lt;dot&gt; com">Kelvin Hu</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
        </p>
      </div>
    </div>
  </body>
</html>
