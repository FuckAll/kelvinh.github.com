#+TITLE:       SICP学习笔记和习题解答
#+AUTHOR:      Kelvin Hu
#+EMAIL:       ini.kelvin@gmail.com
#+DATE:        2012-12-10 Sun
#+URI:         /wiki/sicp/
#+KEYWORDS:    sicp, scheme
#+TAGS:        :SICP:Scheme:
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+DESCRIPTION: learning notes of book Structure and Interpretation of Computer Programs


这里记录了我在学习SICP的过程中的一点笔记，以及作业解答，现在还正在学习中。。（因为作业太多了，读起来真慢。。）

* 构造过程抽象

** 求值模型

   - 正则序求值：先将复合式代入实际参数，再逐渐展开，直到得到一个只包含基本运算符的表达式，再对其进行求值。（完全展开而后归约）

   - 应用序求值：对于复合型表达式，将能进行计算的一些子表达式求值，再对其进行展开，再求值能够进行计算的子表达式，直到求出最终结果。（展开一层归约一层）

** 练习1.2

   : (/ (+ 5 4 (- 2 (- 3 (+ 6 (/ 4 5))))) (* 3 (- 6 2) (- 2 7)))

** 练习1.3

   : the answer below is wrong!!!
   : (define (sum-of-max-two a b c)
   :     (cond ((< a b) (if (< a c) (+ b c) (+ a b)))
   :           (else (if (< b c) (+ a c) (+ a b)))))

** 练习1.5

   初看到 =(define (p) (p))= 这样的定义吓了我一跳，细看其实是一个递归函数的定义，但由没有退出条件，所以一旦有 =(p)= 这样的调用，程序将陷入死循环。

   再看 =(test 0 (p))= ，如果是正则序，那么会完全展开再求值，于是会有如下过程：

   : 1. (if (= 0 0) 0 (p))
   : 2. (if #t 0 (p))
   : 3. return value, 0

   如果是应用序，则会先求值 =(p)= ，于是程序陷入死循环。

** 练习1.6

   这个题目看了半天，大概猜到是跟求值模型相关的，但在解释器racket上试，和使用原始版本的if结果一模一样。。

   于是，无奈Google之，发现[[http://blog.csdn.net/xuanyun/article/details/1331872][此帖]]，讲得很详细，看来对求值模型还是理解不够，但关键是，racket解释器在实验练习1.5时明明是陷入死循环了，说明是应用序才对，但这里又工作得好好的，真让人搞不懂。。

** 练习1.7

   另一个 =good-enough?= 函数：

   : (define (good-enough? guess x)
   :   (< (/ (abs (- (improve guess x) guess)) guess) 0.00001))

   这个函数不是用绝对误差来作比较，而是用两次guess的变化率来比较，这在处理很小的数时会比较有用，比方说小数0.0000000001这种，但在处理大数时，反而会增加误差，因为计算变化率的分母很大，导致分子很大时依然能满足要求，所以在处理大数时不如先前版本的绝对误差精确。

** 练习1.8

   牛顿法解立方根：

   : (define (3sqrt guess x)
   :   (if (good-enough? guess x)
   :       guess
   :       (3sqrt (improve guess x) x)))
   :
   : (define (improve guess x)
   :   (/ (+ (/ x (* guess guess)) (* 2 guess)) 3))
   :
   : (define (good-enough? guess x)
   :   (< (/ (abs (- (improve guess x) guess)) guess) 0.00001))

** 线性递归和迭代

   作为一个递归过程，但其计算过程可能会是递归的，也可能是迭代的。以阶乘计算为例：

   : ;; 第一种定义
   : (define (factorial n)
   :   (if (= n 1)
   :       1
   :       (* n (factorial (- n 1)))))

   : ;; 第二种定义
   : (define (factorial n)
   :   (define (fact-iter result counter)
   :     (if (> counter n)
   :         result
   :         (fact-iter (* result counter) (+ counter 1))))
   :   (fact-iter 1 1))

   毫无疑问两种定义都使用了递归过程，但两者有些不同：第一种在计算时会导致 =factorial= 自身的展开，而且用于计算的n越大，展开的层数越多；第二种在计算时，只需要维护 =result= 以及 =counter= 两个变量即可。

   在上面的例子中，第一种定义就是递归计算过程，第二种则是迭代计算过程。由于两者都是线性的，所以都是线性过程。（所谓线性是指，第一种的展开长度对于n是线性增长的；第二种的计算步骤对于n是线性增长的）

** 练习1.9

   : (inc (+ 3 5))
   : (inc (inc (+ 2 5)))
   : (inc (inc (inc (+ 1 5))))
   : (inc (inc (inc (inc (+ 0 5)))))
   : (inc (inc (inc (inc 5))))
   : (inc (inc (inc 6)))
   : (inc (inc 7))
   : (inc 8)
   : 9

   这是一个递归计算过程

   : (+ 3 6)
   : (+ 2 7)
   : (+ 1 8)
   : (+ 0 9)
   : 9

   这是一个迭代计算过程

** 练习1.10

   : (A 1 10) => 1024
   : (A 2 4)  => 65536
   : (A 3 3)  => 65536

   : f(n) = 2n
   : g(n) = 2^n
   : h(n) = 2^h(n-1)

** 练习1.11

   n < 3, f(n) = n; n >= 3, f(n) = f(n-1) + 2f(n-2) + 3f(n-3)

   递归过程：

   : (define (f n)
   :   (cond ((< n 3) n)
   :         (else (+ (f (- n 1))
   :                  (* 2 (f (- n 2)))
   :                  (* 3 (f (- n 3)))))))

   迭代过程：

   a = f(2) = 2, b = f(1) = 1, c = f(0) = 0
   a <= a + 2b + 3c
   b <= a
   c <= b

   : (define (f2 n)
   :   (f2-iter 2 1 0 n))
   :
   : (define (f2-iter a b c count)
   :   (if (= count 0)
   :       c
   :       (f2-iter (+ a (* 2 b) (* 3 c)) a b (- count 1))))

** 练习1.12

   杨辉三角的规律：f(n, 1) = f(n, n) = 1, f(n, m) = f(n-1, m-1) + f(n-1, m), 1 < m < n

   : (define (pascal-triangle n m)
   :   (if (or (= m 1) (= m n))
   :       1
   :       (+ (pascal-triangle (- n 1) (- m 1))
   :          (pascal-triangle (- n 1) m))))

** 练习1.13

   +暂时跳过，现在手头只有一台电脑，草稿纸和笔都没有，无法证明。。+

   整个计算过程涉及到一些数学符号，如果只用文本格式写会很蛋疼，于是，只写个思路：

   1. 按提示，证明 =Fib(n) = (φ^n - ψ^n) / √5= ，其中 =φ = (1 + √5) / 2= ， =ψ = (1 - √5) / 2= ，证明过程比较简单，根据数学归纳法和Fib(n)的定义即可。

   2. 之后，要证明Fib(n)是最接近φ^n/√5的整数，只需要证明 =|Fib(n) - φ^n/√5| ≤ 0.5= 即可。经过化简，需要证明的不等式变成 =|ψ^n / √5| ≤ 0.5= 。

   3. 经过观察， =|ψ^n / √5|= 实际上是趋于0的极限，所以只需要证明两点即可：

      1. =|ψ^n / √5| ≤ |ψ^(n-1) / √5|=
      2. =|ψ^0 / √5| ≤ 0.5=

      这两点都是比较好证明的。于是再反推回到第二步，就证明了Fib(n)是离φ^n/√5最近的整数。

** 练习1.14

   *再略过。。手头没有笔和纸，泪流满面。。*

** 练习1.15

   a) 这个问题一时半会儿不知道如何作答，就直接暴力地在函数 =p(x)= 的定义中加了一个打印函数来打印x以确定被调用了几次，结果显示， =(sine 12.15)= 调用了5次 =p(x)= 函数。

   b) 对 =(sine a)= 进行展开，第一次后a变成a/3，第二次变成a/9，所以，在n次之后，a变成了a除以3的n次方。空间和步数是正比于展开次数n的，所以，n关于a的阶就是空间和步数关于a的阶。展开的终止条件是 =a / 3^n ≤ 0.1= ，可以求出 =n ≥ log3(10a)= ，即n会大于等于以3为底10a的对数。所以空间和步数关于a的增长阶是对数的。

** 练习1.16

   题目要求：1.只能用迭代，不能递归；2.增长的阶是对数级。

   被这个题的提示给坑到了。。因为提示说维持一个附加变量a来保存计算值，于是我就按提示构造了一个状态变量a，打算用来保存每次迭代的计算值，但经过演算发现必须在第一步迭代将a从1直接给过渡到b^(n/2)，不然后面的迭代没法继续，但这肯定是不可能的。。

   无奈，去网上搜了一下，当我看到下面这两个等式的时候，我瞬间就明白了：

   1. n为偶数时：a(b^2)^(n/2) = ab^n
   2. n为奇数时：ab*b^(n-1) = ab^n

   按上面的等式写出迭代过程：

   : n为偶数时：
   : a <= a
   : b <= b^2
   : n <= n / 2
   :
   : n为奇数时：
   : a <= a * b
   : b <= b
   : n <= n - 1

   于是，解答如下：

   : (define (fast-expt b n)
   :   (fast-expt-iter 1 b n))
   :
   : (define (fast-expt-iter a b n)
   :   (cond ((= n 0) a)
   :         ((even? n) (fast-expt-iter a (* b b) (/ n 2)))
   :         (else (fast-expt-iter (* a b) b (- n 1)))))
   :
   : (define (even? n)
   :   (= (remainder n 2) 0))

   这明明是a和b共同保存中间值，以2^10为例，10 => 5 => 4 => 2 => 1 => 0，大多时候a都在打酱油，而b才是保存中间值的主力。。

** 练习1.17

   : (define (my* a b)
   :   (cond ((= b 0) 0)
   :         ((even? b) (my* (double a) (halve b)))
   :         (else (+ a (my* a (- b 1))))))
   :
   : (define (double a)
   :   (+ a a))
   :
   : (define (halve a)
   :   (/ a 2))

** 练习1.18

   有了1.16的基础，再来这道题就好多了，这题的难点是构造类似1.16中的ab^n。和1.16不同，这里的构造等式如下（状态变量定义为s）：

   1. b为偶数：s + ab = s + a*2 * b/2
   2. b为奇数：s + ab = (s + a) + a * (b - 1)

   于是，有如下解：

   : (define (my* a b)
   :   (my*-iter 0 a b))
   :
   : (define (my*-iter s a b)
   :   (cond ((= b 0) s)
   :         ((even? b) (my*-iter s (double a) (halve b)))
   :         (else (my*-iter (+ s a) a (- b 1)))))

** 练习1.19

   这个题是要求p'和q'，根据T^2 = T'，可以得到两个关于p'和q'的方程，联立方程可得解。

   这两个二元一次方程本身不难，但因为项太多，还有平方，所以如果打字打出来会很蛋疼，所以就不打了，最后解出的结果是：

   : p' = p^2 + q^2
   : q' = q^2 + 2pq

   吐槽：外国人真尼玛牛，一个特例斐波那契数列，能想到通用的T变换，而且，还尼玛T^2 = T'。。

** 练习1.20

   个人觉得这个题的水平略低，因为只是按照定义对过程调用进行展开而已。关键是，如果你展开的内容少一点也可以接受，但是 =(gcd 206 40)= 的正规序展开内容太多了，我写了几层，就写不下去了。。最后看了[[http://www.billthelizard.com/2010/01/sicp-exercise-120-gcd.html][这里]]的详细展开内容，那哥们真是耐得住。。其实题目的意思大概是想让我们对这两种展开方式有一个比较深刻的理解，但这样大量的重复性工作，显得没有必要，所以我没有耐得住寂寞展开到最后。。从那哥们展开的结果来看，最后的答案是18和4。

** 练习1.21

   把书中的的 =smallest-divisor= 及相关定义照执行一遍就行了，结果如下：

   : (smallest-divisor 199)    => 199
   : (smallest-divisor 1999)   => 1999
   : (smallest-divisor 19999)  => 7

   PS：SICP中文翻译中错误很多啊，比方说上面跟 =smallest-divisor= 相关的 =divides?= 定义，其中对 =remainder= 过程的调用就把参数a和b写反了，坑爹。。页脚的注释d/n应该是n/d。。

** 练习1.22

   我使用的Scheme实现是Racket，这个实现并没有包含如题目中所说的 =runtime= ，于是我Google了一下，发现有一个过程叫 =current-inexact-milliseconds= 可以达到要求，于是就用它代替了 =runtime= 。

   这个题目的实现代码如下：

   : (define (timed-prime-test n)
   :   (newline)
   :   (display n)
   :   (start-prime-test n (current-inexact-milliseconds)))
   :
   : (define (start-prime-test n start-time)
   :   (if (prime? n)
   :       (report-time (- (current-inexact-milliseconds) start-time))
   :       #f))  ;; 这里因为Racket实现不允许if只有一个分支，所以用#f来表示另一个分支
   :
   : (define (report-time elapsed-time)
   :   (display " *** ")
   :   (display elapsed-time))
   :
   : (define (search-for-primes start count)
   :   (cond ((= count 0) (newline))
   :         ((timed-prime-test start) (search-for-primes (next-odd start) (- count 1)))
   :         (else (search-for-primes (next-odd start) count))))
   :
   : (define (next-odd n)
   :   (if (= (remainder n 2) 0)
   :       (+ 1 n)
   :       (+ 2 n)))

   测试了几组数据，得到以下结果（不是奇数的行已删去）：

   : 100000000003 *** 24.06689453125
   : 100000000019 *** 14.223876953125
   : 100000000057 *** 15.403076171875
   : >
   : 1000000000039 *** 49.025146484375
   : 1000000000061 *** 48.720947265625
   : 1000000000063 *** 47.57080078125
   : >
   : 10000000000037 *** 154.43701171875
   : 10000000000051 *** 143.823974609375
   : 10000000000099 *** 147.25390625

   取平均值除了一下，时间比值为2.706和3.066，这两个离√10还差得比较多，不过可能是受CPU，系统环境的影响，随机性较强，不过比值应该是√10这一点还是很明确的。

** 练习1.23

   : (define (next n)
   :   (if (= n 2)
   :       3
   :       (+ n 2)))
   :
   : (define (find-divisor n test)
   :   (cond ((> (* test test) n) n)
   :         ((divides? n test) test)
   :         (else (find-divisor n (next test)))))

   得到结果如下（取了三组和1.22中对应的值）：

   : 100000000003 *** 14.049072265625
   : 100000000019 *** 10.261962890625
   : 100000000057 *** 9.14697265625
   : >
   : 1000000000039 *** 40.97705078125
   : 1000000000061 *** 30.837890625
   : 1000000000063 *** 31.4189453125
   : >
   : 10000000000037 *** 103.964111328125
   : 10000000000051 *** 102.067138671875
   : 10000000000099 *** 94.930908203125

   分别计算平均消耗时间比值，得到三个值：1.61，1.41，1.48，这几个值是明显是小于2的。可能虽然步数是少了一半，但是在运行过程中的一些其它消耗，导致了时间比值小于2。

   然后我又试了一下，证明这多出来的时间消耗是来自 =next= 过程调用，将 =find-divisor= 以及 =smallest-divisor= 过程进行重定义为以下形式：

   : (define (find-divisor n test)
   :   (cond ((> (* test test) n) n)
   :         ((divides? n test) test)
   :         (else (find-divisor n (+ test 2))))) ;; 直接加2，不再调用next过程
   :
   : (define (smallest-divisor n)
   :   (find-divisor n 3)) ;; 直接从3开始

   结果如下：

   : 100000000003 *** 13.234130859375
   : 100000000019 *** 8.0458984375
   : 100000000057 *** 7.89599609375
   : >
   : 1000000000039 *** 28.672119140625
   : 1000000000061 *** 25.3388671875
   : 1000000000063 *** 25.071044921875
   : >
   : 10000000000037 *** 78.4560546875
   : 10000000000051 *** 78.115966796875
   : 10000000000099 *** 71.85498046875

   可以看到，这里的时间消耗确实是比1.22中减半了。

** 练习1.24

   这个练习，将 =start-prime-test= 中的 =prime?= 换成 =fast-prime?= 即可：

   : (define (start-prime-test n start-time)
   :   (if (fast-prime? n 3)  ;; 测试的次数取3
   :       (report-time (- (current-inexact-milliseconds) start-time))
   :       #f))

   然后进行测试，得到以下结果（最高只能到10的9次方，因为再高的话，超过了int型的最大值，这时 =random= 函数会报错）：

   : 1009 *** 0.014892578125
   : 1013 *** 0.01611328125
   : 1019 *** 0.015869140625
   : >
   : 10007 *** 0.02099609375
   : 10009 *** 0.02099609375
   : 10037 *** 0.02001953125
   : >
   : 100003 *** 0.02490234375
   : 100019 *** 0.02392578125
   : 100043 *** 0.02392578125
   : >
   : 1000003 *** 0.028076171875
   : 1000033 *** 0.028076171875
   : 1000037 *** 0.029052734375
   : >
   : 10000019 *** 0.032958984375
   : 10000079 *** 0.033203125
   : 10000103 *** 0.032958984375
   : >
   : 100000007 *** 0.0380859375
   : 100000037 *** 0.0380859375
   : 100000039 *** 0.0380859375
   : >
   : 1000000007 *** 0.041015625
   : 1000000009 *** 0.0419921875
   : 1000000021 *** 0.0419921875

   增长速度是O(log n)，所以10^6附近应该是10^3附近所消耗时间的两倍，10^9是三倍：从上面的结果来看，10^6次方的数据比较接近（0.028/0.014），但10^9则要小了不少，只有大概2.67倍左右；10^8应该是10^4的两倍，这个数据也还比较接近（0.038/0.020）。

** 练习1.25

   其实这个问题的答案在前面的脚注46中就说了：

   #+begin_quote
   这种技术非常有用，因为它意味着我们的计算中不需要去处理比m大很多的数（请与练习1.25比较）。
   #+end_quote

   原来的 =expmod= 函数是利用了以下的等式：

   : (x * y) % m = [(x % m) * (y % m)] % m

   这样，如果 =x*y= 的值很大的话，可以分解成两个小于m的数再取模，这样计算起来就要容易很多。

   而1.25中的 =expmod= 的定义也是没问题的：先算出乘方值，再取模。但是需要注意的是，这个乘方值可能很大，这样再求模，可能就会很慢，没有办法和原来版本的高效性相提并论。

** 练习1.26

   这个题还比较好理解，在使用 =square= 的时候，只需要在 =expmod= 内部执行一次递归调用，但直接使用乘法的话，会执行两次递归调用，情况如下：

   | 次数  | 递归情况(square)   | 递归情况(*)            |
   |------+------------------+-----------------------|
   |    1 | n                | n                     |
   |    2 | n/2              | n/2 * n/2             |
   |    3 | n/4              | n/4 * n/4 * n/4 * n/4 |
   |  ... |                  |                       |

   注：上表没有考虑 =n-1= 的情况，因为 =n-1= 作为常数级的衰减（请原谅，我自己发明了“衰减”这个词），和指数级衰减比起来可以忽略。

   可以看到，使用 =square= 的情况是指数级衰减，所以最终是Θ(log n)；直接使用乘法虽然也是指数级衰减，但是衰减的同时，递归调用数却在指数级增加，刚好和衰减抵消，于是就是Θ(n)。

** 练习1.27

   这个题目比较简单，定义的两个函数如下：

   : (define (carmichael-check n a)
   :   (cond ((not (= (expmod a n n) a)) false)
   :         ((> a 1) (carmichael-check n (- a 1)))
   :         (else true)))
   :
   : (define (carmichael-test n)
   :   (carmichael-check n (- n 1)))

   需要测试Carmichael数的时候，执行 =carmichael-test= 即可。这个测试有一点缺陷就是，不能把真正的质数和Carmichael数分开，不过题目是要求验证Carmichael数，而并不是求Carmichael数，所以这点缺陷也不算是缺陷。
