#+TITLE:       Project Euler的解题笔记
#+AUTHOR:      Kelvin Hu
#+EMAIL:       ini.kelvin@gmail.com
#+DATE:        2013-05-05 Sun
#+URI:         /wiki/project-euler/
#+KEYWORDS:    math, algorithm, http:://projecteuler.net
#+TAGS:        :Math:Algorithm:Elisp:
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+DESCRIPTION: notes about solving problems on projecteuler.net


在偶然之间，得知了[[projecteuler.net]]这个网站（以下简称PE）。下面这段话摘自它的about页面的最底端：

#+BEGIN_QUOTE
Project Euler exists to encourage, challenge, and develop the skills and enjoyment of anyone with an interest in the fascinating world of mathematics.
#+END_QUOTE

这是一个用编程来解决数学问题的网站，这个站点和一般OJ有很大不同：其一，所有问题都是数学问题；其二，不用提交代码，也没限定时间和内存，需要提交的只是一个最终结果。当然，在它的about页面也写了，还是希望你用来解决问题的程序能在一分钟内跑出结果，因为如果一个程序跑了一年才出结果，那么这个程序也没多大用处。

当然，在网上发表自己的解题方案也是PE所不推荐的，这是about页面的某个 Q & A ：

#+BEGIN_QUOTE
I learned so much solving problem XXX so is it okay to publish my solution elsewhere?

It appears that you have answered your own question. There is nothing quite like that "Aha!" moment when you finally beat a problem which you have been working on for some time. It is often through the best of intentions in wishing to share our insights so that others can enjoy that moment too. Sadly, however, that will not be the case for your readers. Real learning is an active process and seeing how it is done is a long way from experiencing that epiphany of discovery. Please do not deny others what you have so richly valued yourself.
#+END_QUOTE

但鉴于我这个站的访问量基本没有，而且出于炫耀心理，所以还是把解题方案贴在这里。主啊，请原谅我吧。 :-p


* Problem 1

  关于问题1的描述：

  #+BEGIN_QUOTE
  Multiples of 3 and 5

  If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
  Find the sum of all the multiples of 3 or 5 below 1000.
  #+END_QUOTE

  也就是求小于1000的3或5的倍数的数的和。鉴于这个题目挺简单，我就直接在Emacs里面用Elisp给解决了（我这个解题思路可能有点怪:-D）：

  : (funcall
  :  (lambda (max)
  :    (let ((m3 3) (m5 5) (sum 0))
  :      (while (< m3 max)
  :        (setq sum (+ sum
  :                     (if (= (% m3 5) 0) 0 m3)
  :                     (if (< m5 max) m5 0)))
  :        (setq m3 (+ m3 3))
  :        (setq m5 (+ m5 5)))
  :      sum))
  :  1000)

  个人觉得这个解法比PE论坛上大部分从3开始遍历到1000的解法要好，因为这样迭代直接去掉了不是3或者5的倍数的验证过程（自从看了SICP之后，对迭代越来越感兴趣了:-p）。程序中之所以存在判断m3是不是5的倍数的那部分，是因为m3有可能是5的倍数，这样会导致其被加两遍，所以，碰到这种情况要将其除掉。

  但这个并不是最优解。每个问题解决之后，PE会给出一个“标准”答案，这个问题的“标准”答案如下：

  : sum_multi(1000) = sum_multi_3(1000) + sum_multi_5(1000) - sum_multi_15(1000)
  : sum_multi_3(1000) = 3 + 6 + 9 + ... + 999
  :                   = 3 × (1 + 2 + ... + 333)
  :                   = 3 × (1 + 333) × 333 ÷ 2
  : sum_multi_5(1000) 和 sum_multi_15(1000) 类推

  依据上述解法，写出Elisp的程序如下（这个解法的性能要好上XX倍 :-D）：

  : (defun sum(factor max)
  :   (let ((count (/ max factor)))
  :     (* factor
  :        (/ (* count
  :              (+ 1 count))
  :           2))))
  :
  : (funcall
  :  (lambda (max)
  :    (- (+ (sum 3 max)
  :          (sum 5 max))
  :       (sum 15 max)))
  :  999)

* Problem 2

  关于问题2的描述：

  #+BEGIN_QUOTE
  Even Fibonacci numbers

  Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

  1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

  By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
  #+END_QUOTE

  也就是求斐波那契数列所有项值不超过四百万并且为偶数的和。同样，直接在Emacs里面用Elisp解决（解题思路同样比较怪:-D）：

  : (funcall
  :  (lambda (max)
  :    (let ((3i 2) (3i+1 3) (3i+2 5) (sum 0))  ;; 这里的3i+1, 3i+2是变量，不是运算
  :      (while (<= 3i max)
  :        (setq sum (+ sum 3i))
  :        (setq 3i (+ 3i+1 3i+2))
  :        (setq 3i+1 (+ 3i 3i+2))
  :        (setq 3i+2 (+ 3i 3i+1)))
  :      sum))
  :  4000000)

  因为注意到序号为3的倍数（我习惯以1,1,2来开始斐波那契数列，所以序号为3的倍数，如果以问题描述中为例，这个规律应该是2+3n）的项是偶数，所以只需要处理这些项就可以了。同问题1，采用迭代的方式，计算基本都是加法，连PE论坛中大多数普通循环解法中的求模运算都没用到。

  PS：因为这个解法就是“标准”答案的思路，所以这里就不分析“标准”答案了。 :-p

* Problem 3

  关于问题3的描述：

  #+BEGIN_QUOTE
  The prime factors of 13195 are 5, 7, 13 and 29.

  What is the largest prime factor of the number 600851475143 ?
  #+END_QUOTE

  也就是求数字600851475143的最大质数因子。

  这个题目就有点讲究了，数字比较大，而分解大数也没什么好的办法，基本是需要一轮一轮的循环，而判断一个数是不是质数，基本也是需要一轮一轮循环去除，直到它的平方根为止。

  但是，这里面还是有可以优化的地方，就是用来测试一个数是否为质数的算法，本来应该是O(n)的复杂度，我们可以将其优化至O(log n)，原理，就是著名的费马小定理[fn:1]：

  #+BEGIN_QUOTE
  费马小定理：如果n是一个素数，a是小于n的任意正整数，那么a的n次方与a模n同余。
  #+END_QUOTE

  根据费马小定理，可以引申出费马检查算法：选取一个小于n的a，如果n和a满足费马小定理，那么n是素数的可能性就很大，如果不满足，那么n一定不是素数。在满足定理的情况下，我们可以再选择其它的a来测试，这样，在选取一定次数的a之后，如果定理一直满足，我们就可以认为n是素数。

  费马检查不是一个精确的检查，而只是表明一个数是素数的概率，但是，由于对于非素数n，大多数的a < n都不会满足定理，所以，如果有一个a能通过检查，n是素数的概率就大于50%，如果有两个a能通过检查，n是素数的概率就大于75%，因此，只需要少量的a，就可以让概率达到很高的值。

  下面的代码是费马检查的Elisp实现：

  : (defun even? (n)
  :   (= (% n 2) 0))
  :
  : (defun square (n)
  :   (* n n))
  :
  : (defun expmod (base exp m)
  :   (cond ((= exp 0) 1)
  :         ((even? exp) (% (square (expmod base (/ exp 2) m)) m))
  :         (t (% (* base (expmod base (- exp 1) m)) m))))
  :
  : (defun fermat-test (n)
  :   (defun try-it (a)
  :     (= (expmod a n n) a))
  :   (try-it (+ 1 (random (- n 1)))))
  :
  : (defun fast-prime? (n times)
  :   (cond ((= times 0) t)
  :         ((fermat-test n) (fast-prime? n (- times 1)))
  :         (t nil)))

  =fast-prime?= 函数接收两个参数，一个要用来测试的数n，一个是执行费马检查的次数。整个检查的耗时部分在 =expmod= 函数，但是它的复杂度也只有O(log n)。

  基于上面的基础，我们就可以得出问题3的解法（Elisp实现）：

  : (funcall
  :  (lambda (n test-times)
  :    (let ((small-factor 1) (large-factor n)
  :          (found nil) result)
  :      (while (and (not found) (<= small-factor large-factor))
  :        (when (= (% n small-factor) 0)
  :          (when (fast-prime? small-factor test-times)
  :            (setq result small-factor))
  :          (setq large-factor (/ n small-factor))
  :          (when (fast-prime? large-factor test-times)
  :            (setq result large-factor)
  :            (setq found t)))
  :        (setq small-factor (+ 1 small-factor)))
  :      result))
  :  600851475143 2)

  这个实现是比较丑陋的，递增地进行因数测试相当耗时间，幸好是两个因数同时测试，这样可以节省不少时间。另外，Lisp在这里的优势就体现出来了：对于600851475143这样的大数可以直接处理，而在C或者其它一些语言中，就不得不考虑溢出问题了。另外需要说明的是，上面的费马检查的次数设定为2，已经是足够了。

  下面来看看“标准答案”，直接先贴上伪代码：

  : n = "the evil big number"
  :
  : if n mod 2 = 0 then
  :     lastFactor = 2
  :     n = n div 2
  :     while n mod 2 = 0
  :         n = n div 2
  : else
  :     lastFactor = 1
  :
  : factor = 3
  : maxFactor = sqrt(n)
  : while n > 1 and factor <= maxFactor
  :     if n mod factor = 0 then
  :         n = n div factor
  :         lastFactor = factor
  :         while n mod factor = 0
  :             n = n div factor
  :         maxFactor = sqrt(n)
  :    factor=factor+2
  : if n = 1 then
  :     output lastFactor
  : else
  :     output n

  “标准答案”基于两个事实：1. 任何正整数都可以被分解为多个素数因子的的积（如果把1也当作素数的话）；2. 一个正整数，最多只能有一个大于其平方根的素数因子。

  因此，“标准答案”就是一个不停解质因数的过程，小学的时候就学过，可是我看这个算法还是看来好久才明白原理，可怜了我那无下限的智商。。。

* Problem 4

  关于问题4的描述：

  #+BEGIN_QUOTE
  A palindromic number reads the same both ways. The largest palindrome made from the product of two 2-digit numbers is 9009 = 91 × 99.

  Find the largest palindrome made from the product of two 3-digit numbers.
  #+END_QUOTE

  即求两个3位数相乘所能得到的最大回文数。所谓回文数，即从最高位到最低位的数字顺序与最低位到最高位的数字顺序完全一样，例如12321。

  这个算是比较简单的一个题目，依旧使用Elisp：

  : (defun check-palindromic (n)
  :   (let (numbers)
  :     (setq numbers (list (% n 10)))
  :     (setq n (/ n 10))
  :     (while (> n 0)
  :       (nconc numbers `(,(% n 10)))
  :       (setq n (/ n 10)))
  :     (equal numbers (reverse numbers))))
  :
  : (funcall
  :  (lambda (min max)
  :    (let ((s max) (l max) (result 0) temp)
  :      (while (>= s min)
  :        (setq l s)
  :        (while (>= l min)
  :          (setq temp (* s l))
  :          (when (and (< result temp)
  :                     (check-palindromic temp))
  :            (setq result temp))
  :          (setq l (1- l)))
  :        (setq s (1- s)))
  :      result))
  :  100 999)

  首先定义一个 =check-palindromic= 函数用于判断一个数是不是回文数，做法就是取出所有数字组成一个列表，然后检查反转后的列表和原列表是否相同。程序主体部分定义了一个lambda函数，以1为步长进行双重循环逐个判断即可。这里需要注意的就是类似10=2×5=5×2两个因数位置互换的情况，需要在双重循环中过滤掉。

  至于“标准答案”中的最优解，采用分解因式的方法，确定满足要求的数必定可以分解为11和另外一个数的乘积（请自行证明），所以两个因子中有一个必定是11倍数，从而能让普通解法中的循环的递增/递减步长从1变为11，这大大减少了运行时间。

  但不得不说的是，这个最优解是有前提的，即已经限定满足要求的数是六位数，所以不具有普遍性，因此我也就不贴最优解的解法了，因为普通解对这个题目已经是足够了，反而感觉最优解有点画蛇添足。

* Footnotes

[fn:1] 关于费马小定理以及费马检查部分的内容来自SICP的1.2.6节，代码实现是我根据书上的Scheme实现来写了一个Elisp的版本。
