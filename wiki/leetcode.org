#+TITLE:       LeetCode题解
#+AUTHOR:      Kelvin Hu
#+EMAIL:       ini.kelvin@gmail.com
#+DATE:        2016-01-20 Wed
#+URI:         /wiki/leetcode-answers/
#+KEYWORDS:    algorithm, C++, leetcode
#+TAGS:        Algorithm, C++, LeetCode
#+LANGUAGE:    en
#+OPTIONS:     H:3 num:nil toc:t \n:nil @:t ::t |:t ^:nil -:t f:t *:t <:t
#+DESCRIPTION: 我个人的LeetCode OJ题解


之前无数的事实证明，我是一个挖坑的好手。。。这又是一个无比大的坑，不求其它，只求能填上。。。挖坑不填是SB。。。

* Two Sum

#+BEGIN_QUOTE
Given an array of integers, find two numbers such that they add up to a specific target number.

The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.

You may assume that each input would have exactly one solution.

Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2
#+END_QUOTE

最简单的想法，自然是两层for循环数组，一个个去加了试：

#+BEGIN_SRC C++
  class Solution {
  public:
      vector<int> twoSum(vector<int>& nums, int target) {
          vector<int> vec;
          for (int i = 0; i < nums.size(); ++i) {
              for (int j = i + 1; j < nums.size(); ++j) {
                  if (nums[i] + nums[j] == target) {
                      vec.push_back(i + 1);
                      vec.push_back(j + 1);
                      return vec;
                  }
              }
          }

          return vec;
      }
  };
#+END_SRC

但结果可想而知，时间超时了。。。这个复杂度是平方级别，看来是不满足要求。经过思考，觉得先给数组排个序会比较好，再查找的话，可以用二分搜索：

#+BEGIN_SRC C++
  class Solution {
  public:
      struct entity {
          int num;
          int index;

          entity(int n, int i) : num(n), index(i) {}

          bool operator<(const entity& that) const {
              return this->num < that.num;
          }
      };

      vector<int> twoSum(vector<int>& nums, int target) {
          vector<int> ret;

          vector<entity> sorted_num;
          for (int i = 0; i < nums.size(); ++i)
              sorted_num.push_back(entity(nums[i], i + 1));
          sort(sorted_num.begin(), sorted_num.end());

          vector<entity>::iterator it, end;
          for (it = sorted_num.begin(), end = sorted_num.end(); it != end;) {
              int op = target - it->num;
              vector<entity>::iterator op_it = lower_bound(++it, end, entity(op, 0));
              if (op_it->num == op) {
                  --it;

                  int idx1 = it->index;
                  int idx2 = op_it->index;
                  if (idx1 > idx2)
                      swap(idx1, idx2);

                  ret.push_back(idx1);
                  ret.push_back(idx2);
                  return ret;
              }
          }

          return ret;
      }
  };
#+END_SRC

经过改造之后，时间复杂度降到了O(nlogn)级别，所以通过了，这个理论上应该不会有更低的复杂度了，毕竟要遍历一遍。。。

* Add Two Numbers

#+BEGIN_QUOTE
You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.

Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
Output: 7 -> 0 -> 8
#+END_QUOTE

这个题目应该是很简单的，创建一个循环直到两个链表都空了为止，每个循环把两个数加起来，如果有进位，标记一下，下一轮进位。需要注意的是，在循环结束之后，如果还有进位，记得增加一个值为1的结点。代码如下：

#+BEGIN_SRC C++
  /**
   ,* Definition for singly-linked list.
   ,* struct ListNode {
   ,*     int val;
   ,*     ListNode *next;
   ,*     ListNode(int x) : val(x), next(NULL) {}
   ,* };
   ,*/
  class Solution {
  public:
      ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
          bool carry = false;
          ListNode dummy(-1);
          ListNode *last = &dummy;

          while (true) {
              if (!l1 && !l2)
                  break;

              int val1 = l1 ? l1->val : 0;
              int val2 = l2 ? l2->val : 0;

              int sum = val1 + val2;
              if (carry) {
                  sum += 1;
                  carry = false;
              }

              if (sum >= 10) {
                  sum -= 10;
                  carry = true;
              }

              last->next = new ListNode(sum);
              last = last->next;

              l1 = l1 ? l1->next : NULL;
              l2 = l2 ? l2->next : NULL;
          }

          if (carry)
              last->next = new ListNode(1);

          return dummy.next;
      }
  };
#+END_SRC

其实还有一个更好一点的解法：在一个链表结束后，直接把另外一个长链表剩下的部分挂到结果链表上，处理好进位即可。

* Longest Substring Without Repeating Characters

#+BEGIN_QUOTE
Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.
#+END_QUOTE

这个是查找字符串中最长无重复字符字串的问题。可以假设我已经有一个最长无重复的子串，那么下一步如何做？自然是判断下一个字符在这个子串里有没有，如果没有，加入这个字符，继续查找下一个；如果有，那么就把当前串里这个字符及以前的部分切掉，剩下的仍然是一个无重复的最大子串，继续查找下一个即可。但有一个关键点是，如果高效查找这个子串里是不是已经存在某个字符。简单的自然是循环一遍，不过因为字符数量有限，我采用了数组保存的方式，这样查找就能降到O(1)级别。代码如下：

#+BEGIN_SRC C++
  class Solution {
  public:
      int lengthOfLongestSubstring(string s) {
          int start = 0;
          int end = 0;
          int longest = 0;

          int position[256] = {0};

          while (end < s.length()) {
              char c = s[end];
              int& pos = position[c];
              if (pos) {
                  int len = end - start;
                  if (len > longest)
                      longest = len;

                  int old_start = start;
                  start = pos;

                  for (int i = old_start; i < pos; ++i)
                      position[s[i]] = 0;
              }

              pos = end + 1;
              ++end;
          }

          int len = end - start;
          if (len > longest)
              longest = len;

          return longest;
      }
  };
#+END_SRC

其中 =position[256]= 保存了字符在串中的位置，但因为0被用来表示没有出现，所以位置就只能从1开始了，所以那个 =pos = end + 1;= 看起来就会比较别扭。。。

* Median of Two Sorted Arrays

#+BEGIN_QUOTE
There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).
#+END_QUOTE

题目的意思是，找两个已经排序的数组的中位数，要求时间复杂度是O(log(m+n))。突然间觉得好对不起我的高中数学老师，我竟然不知道中位数是怎么算的了，google了一下才知道，对一个排好序的数列，如果项数是奇数项，中位数就是最中间的数；如果项数是偶数项，中位数就是最中间两个数的平均数。不过，下面的叙述中，为了方便理解，我们以奇数项为例，偶数项其实是一样，不过因为偶数项的中位数要涉及两个数，所以叙述上要麻烦一些。

这个题目明确标明了是Hard，这也是这几题遇到的第一个Hard级别的题。如果将两个数混在一起排好序，取中间就可以了，但这样必然要到排序O(nlog(m+n))的复杂度，达不到要求。要达到O(log(m+n))的复杂度，必然要针对两个数组使用类似二分查找的算法才能满足。仔细分析了一下，发现我们的需求其实是淘汰掉两个数组中大约一半的最小的数，然后剩下的第一个数就是中位数。记要淘汰的个数为C，那么这个C应该等于(m+n)/2。如何淘汰呢？我们采用二分查找的方式：分别找到数组A、B中的第C/2个数，然后比较，如果A[C/2]大于B[C/2]，那么就直接把数组B中C/2及以前的数都淘汰掉，反之就淘汰掉A中C/2及以前的数。然后C减去已淘汰的个数，继续上述过程，直到C为0为止。那么剩下的两个数组中，最小的数就是中位数。当然，如果数组整体长度不够，就用整体长度来代替C/2。

这个做法的正确性可以采用反证法很好地证明：假设A[C/2] > B[C/2]，于是在淘汰B中的C/2个数时，淘汰了我们需要的中位数，那么这个数的位置P必然小于等于C/2，因为按照我们前面的约定，要淘汰掉C个数然后剩下的第一个才是中位数，那么我们就要找到C个小于等于B[P]的数才行。在B中，能淘汰的数是P-1个，要小于C/2，那么必然要求在A中淘汰大于C/2个数。但我们已经知道，A[C/2] > B[C/2] >= B[P]，那么A中自然是没有足够的数供淘汰的，于是正确性得证。

实现代码如下，因为要不停地去判断是偶数项还是奇数项，还要判断数组长度，所以代码写得比较乱：

#+BEGIN_SRC C++
  class Solution {
  public:
      double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
          int total = nums1.size() + nums2.size();
          int before = (total - 1) / 2;

          int start1 = 0;
          int start2 = 0;

          while (before > 1) {
              if (start1 >= nums1.size()) {
                  start2 += before;
                  if (total % 2 == 0)
                      return (nums2[start2] + nums2[start2 + 1]) * 1.0 / 2;
                  else
                      return nums2[start2];
              }

              if (start2 >= nums2.size()) {
                  start1 += before;
                  if (total % 2 == 0)
                      return (nums1[start1] + nums1[start1 + 1]) * 1.0 / 2;
                  else
                      return nums1[start1];
              }

              int count = before / 2;
              int actual1, n1;
              int actual2, n2;

              int size1 = nums1.size() - start1;
              int size2 = nums2.size() - start2;

              if (count >= size1) {
                  actual1 = size1;
                  n1 = nums1.back();
              } else {
                  actual1 = count;
                  n1 = nums1.at(start1 + count - 1);
              }

              if (count >= size2) {
                  actual2 = size2;
                  n2 = nums2.back();
              } else {
                  actual2 = count;
                  n2 = nums2.at(start2 + count - 1);
              }

              if (n1 > n2) {
                  start2 += actual2;
                  before -= actual2;
              } else {
                  start1 += actual1;
                  before -= actual1;
              }
          }

          if (before == 1) {
              if (start1 >= nums1.size())
                  start2 += 1;
              else if (start2 >= nums2.size())
                  start1 += 1;
              else {
                  if (nums1[start1] > nums2[start2])
                      start2 += 1;
                  else
                      start1 += 1;
              }

              before = 0;
          }

          if (total % 2 == 0) {
              if (start1 >= nums1.size())
                  return (nums2[start2] + nums2[start2 + 1]) * 1.0 / 2;
              else if (start2 >= nums2.size())
                  return (nums1[start1] + nums1[start1 + 1]) * 1.0 / 2;
              else {
                  int m1, m2;
                  if (nums1[start1] > nums2[start2]) {
                      m1 = nums2[start2];
                      start2 += 1;
                  } else {
                      m1 = nums1[start1];
                      start1 += 1;
                  }

                  if (start1 >= nums1.size())
                      m2 = nums2[start2];
                  else if (start2 >= nums2.size())
                      m2 = nums1[start1];
                  else {
                      if (nums1[start1] > nums2[start2])
                          m2 = nums2[start2];
                      else
                          m2 = nums1[start1];
                  }

                  return (m1 + m2) * 1.0 / 2;
              }
          } else {
              if (start1 >= nums1.size())
                  return nums2[start2];
              else if (start2 >= nums2.size())
                  return nums1[start1];
              else {
                  if (nums1[start1] > nums2[start2])
                      return nums2[start2];
                  else
                      return nums1[start1];
              }
          }
      }
  };
#+END_SRC
