<!DOCTYPE html>
<html lang="en-us">
  <head>
    <title>LeetCode题解 - Kelvin的胡言乱语</title>
    <meta charset="utf-8" />
    <meta name="author" content="Kelvin Hu" />
    <meta name="description" content="我个人的LeetCode OJ题解" />
    <meta name="keywords" content="algorithm, C++, leetcode" />
    <link rel="stylesheet" href="/media/css/main.css" type="text/css">
    <link rel="stylesheet" href="/media/css/prettify.css" type="text/css">
  </head>
  <body class="container">
    <div>
      <header class="masthead">
        <h1 class="masthead-title"><a href="/">Kelvin的胡言乱语</a></h1>
        <p>==============&gt; 重剑无锋，大巧不工。</p>
        <ul>
          <li><a href="/blog/">Blog</a></li>
          <li><a href="/wiki/">Wiki</a></li>
          <li><a href="/tags/">Tags</a></li>
          <li><a href="/about/">About</a></li>
          <li><a href="https://github.com/kelvinh">GitHub</a></li>
          <li><a href="/rss.xml">RSS</a></li>
        </ul>
        <form method="get" id="searchform" action="http://www.google.com/search">
          <input type="text" class="field" name="q" id="s" placeholder="Search">
          <input type="hidden" name="as_sitesearch" value="kelvinh.github.io">
        </form>
      </header>
    </div>

<div>
<div class="post">
<h1>LeetCode题解</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">Two Sum</a></li>
<li><a href="#orgheadline2">Add Two Numbers</a></li>
<li><a href="#orgheadline3">Longest Substring Without Repeating Characters</a></li>
</ul>
</div>
</div>
<p>
之前无数的事实证明，我是一个挖坑的好手。。。这又是一个无比大的坑，不求其它，只求能填上。。。挖坑不填是SB。。。
</p>

<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">Two Sum</h2>
<div class="outline-text-2" id="text-orgheadline1">
<blockquote>
<p>
Given an array of integers, find two numbers such that they add up to a specific target number.
</p>

<p>
The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.
</p>

<p>
You may assume that each input would have exactly one solution.
</p>

<p>
Input: numbers={2, 7, 11, 15}, target=9
Output: index1=1, index2=2
</p>
</blockquote>

<p>
最简单的想法，自然是两层for循环数组，一个个去加了试：
</p>

<div class="org-src-container">

<pre class="src src-C++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; vec;
        for (int i = 0; i &lt; nums.size(); ++i) {
            for (int j = i + 1; j &lt; nums.size(); ++j) {
                if (nums[i] + nums[j] == target) {
                    vec.push_back(i + 1);
                    vec.push_back(j + 1);
                    return vec;
                }
            }
        }

        return vec;
    }
};
</pre>
</div>

<p>
但结果可想而知，时间超时了。。。这个复杂度是平方级别，看来是不满足要求。经过思考，觉得先给数组排个序会比较好，再查找的话，可以用二分搜索：
</p>

<div class="org-src-container">

<pre class="src src-C++">class Solution {
public:
    struct entity {
        int num;
        int index;

        entity(int n, int i) : num(n), index(i) {}

        bool operator&lt;(const entity&amp; that) const {
            return this-&gt;num &lt; that.num;
        }
    };

    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        vector&lt;int&gt; ret;

        vector&lt;entity&gt; sorted_num;
        for (int i = 0; i &lt; nums.size(); ++i)
            sorted_num.push_back(entity(nums[i], i + 1));
        sort(sorted_num.begin(), sorted_num.end());

        vector&lt;entity&gt;::iterator it, end;
        for (it = sorted_num.begin(), end = sorted_num.end(); it != end;) {
            int op = target - it-&gt;num;
            vector&lt;entity&gt;::iterator op_it = lower_bound(++it, end, entity(op, 0));
            if (op_it-&gt;num == op) {
                --it;

                int idx1 = it-&gt;index;
                int idx2 = op_it-&gt;index;
                if (idx1 &gt; idx2)
                    swap(idx1, idx2);

                ret.push_back(idx1);
                ret.push_back(idx2);
                return ret;
            }
        }

        return ret;
    }
};
</pre>
</div>

<p>
经过改造之后，时间复杂度降到了O(nlogn)级别，所以通过了，这个理论上应该不会有更低的复杂度了，毕竟要遍历一遍。。。
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">Add Two Numbers</h2>
<div class="outline-text-2" id="text-orgheadline2">
<blockquote>
<p>
You are given two linked lists representing two non-negative numbers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
</p>

<p>
Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)
Output: 7 -&gt; 0 -&gt; 8
</p>
</blockquote>

<p>
这个题目应该是很简单的，创建一个循环直到两个链表都空了为止，每个循环把两个数加起来，如果有进位，标记一下，下一轮进位。需要注意的是，在循环结束之后，如果还有进位，记得增加一个值为1的结点。代码如下：
</p>

<div class="org-src-container">

<pre class="src src-C++">/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        bool carry = false;
        ListNode dummy(-1);
        ListNode *last = &amp;dummy;

        while (true) {
            if (!l1 &amp;&amp; !l2)
                break;

            int val1 = l1 ? l1-&gt;val : 0;
            int val2 = l2 ? l2-&gt;val : 0;

            int sum = val1 + val2;
            if (carry) {
                sum += 1;
                carry = false;
            }

            if (sum &gt;= 10) {
                sum -= 10;
                carry = true;
            }

            last-&gt;next = new ListNode(sum);
            last = last-&gt;next;

            l1 = l1 ? l1-&gt;next : NULL;
            l2 = l2 ? l2-&gt;next : NULL;
        }

        if (carry)
            last-&gt;next = new ListNode(1);

        return dummy.next;
    }
};
</pre>
</div>

<p>
其实还有一个更好一点的解法：在一个链表结束后，直接把另外一个长链表剩下的部分挂到结果链表上，处理好进位即可。
</p>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">Longest Substring Without Repeating Characters</h2>
<div class="outline-text-2" id="text-orgheadline3">
<blockquote>
<p>
Given a string, find the length of the longest substring without repeating characters. For example, the longest substring without repeating letters for "abcabcbb" is "abc", which the length is 3. For "bbbbb" the longest substring is "b", with the length of 1.
</p>
</blockquote>

<p>
这个是查找字符串中最长无重复字符字串的问题。可以假设我已经有一个最长无重复的子串，那么下一步如何做？自然是判断下一个字符在这个子串里有没有，如果没有，加入这个字符，继续查找下一个；如果有，那么就把当前串里这个字符及以前的部分切掉，剩下的仍然是一个无重复的最大子串，继续查找下一个即可。但有一个关键点是，如果高效查找这个子串里是不是已经存在某个字符。简单的自然是循环一遍，不过因为字符数量有限，我采用了数组保存的方式，这样查找就能降到O(1)级别。代码如下：
</p>

<div class="org-src-container">

<pre class="src src-C++">class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int start = 0;
        int end = 0;
        int longest = 0;

        int position[256] = {0};

        while (end &lt; s.length()) {
            char c = s[end];
            int&amp; pos = position[c];
            if (pos) {
                int len = end - start;
                if (len &gt; longest)
                    longest = len;

                int old_start = start;
                start = pos;

                for (int i = old_start; i &lt; pos; ++i)
                    position[s[i]] = 0;
            }

            pos = end + 1;
            ++end;
        }

        int len = end - start;
        if (len &gt; longest)
            longest = len;

        return longest;
    }
};
</pre>
</div>

<p>
其中 <code>position[256]</code> 保存了字符在串中的位置，但因为0被用来表示没有出现，所以位置就只能从1开始了，所以那个 <code>pos = end + 1;</code> 看起来就会比较别扭。。。
</p>
</div>
</div>

</div>
</div>
    <div>
      <div class="post-meta">
        <span title="post date" class="post-info">2016-01-20</span>
        <span title="last modification date" class="post-info">2016-01-26</span>
        <span title="tags" class="post-info"><a href="/tags/algorithm/">Algorithm</a>, <a href="/tags/c++/">C++</a>, <a href="/tags/leetcode/">LeetCode</a></span>
        <span title="author" class="post-info">Kelvin Hu</span>
      </div>
      <script src="http://code.jquery.com/jquery-latest.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.js"></script>
      <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
      <script src="/media/js/main.js"></script>
      <script type="text/javascript">
        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-41088132-1']);
        _gaq.push(['_trackPageview']);
        (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
      </script>
      <div class="footer">
        <p>Generated by <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.x (<a href="http://orgmode.org">Org mode</a> 8.x)</p>
        <p>
          Copyright &copy; 2012 - <span id="footerYear"></span> <a href="mailto:ini &lt;dot&gt; kelvin &lt;at&gt; gmail &lt;dot&gt; com">Kelvin Hu</a>
          &nbsp;&nbsp;-&nbsp;&nbsp;
          Powered by <a href="https://github.com/kelvinh/org-page" target="_blank">org-page</a>
          <script type="text/javascript">document.getElementById("footerYear").innerHTML = (new Date()).getFullYear();</script>
        </p>
      </div>
    </div>

  </body>
</html>
