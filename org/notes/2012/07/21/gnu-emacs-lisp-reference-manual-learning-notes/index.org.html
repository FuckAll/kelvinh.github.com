<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN">
<!-- Created by htmlize-1.40 in css mode. -->
<html>
  <head>
    <title>index.org</title>
    <style type="text/css">
    <!--
      body {
        color: #839496;
        background-color: #002b36;
      }
      .bold {
        /* bold */
        font-weight: bold;
      }
      .comment {
        /* font-lock-comment-face */
        color: #586e75;
        font-style: italic;
      }
      .italic {
        /* italic */
        text-decoration: underline;
      }
      .org-block {
        /* org-block */
        color: #586e75;
      }
      .org-block-begin-line {
        /* org-block-begin-line */
        color: #586e75;
        font-style: italic;
      }
      .org-block-end-line {
        /* org-block-end-line */
        color: #586e75;
        font-style: italic;
      }
      .org-code {
        /* org-code */
        color: #586e75;
      }
      .org-document-info {
        /* org-document-info */
        color: #afeeee;
      }
      .org-document-info-keyword {
        /* org-document-info-keyword */
        color: #586e75;
      }
      .org-document-title {
        /* org-document-title */
        color: #afeeee;
        font-size: 144%;
        font-weight: bold;
      }
      .org-level-1 {
        /* org-level-1 */
        color: #268bd2;
      }
      .org-level-2 {
        /* org-level-2 */
        color: #2aa198;
      }
      .org-meta-line {
        /* org-meta-line */
        color: #586e75;
        font-style: italic;
      }
      .whitespace-line {
        /* whitespace-line */
        color: #ee82ee;
        background-color: #333333;
      }

      a {
        color: inherit;
        background-color: inherit;
        font: inherit;
        text-decoration: inherit;
      }
      a:hover {
        text-decoration: underline;
      }
    -->
    </style>
  </head>
  <body>
    <pre>
<span class="org-document-info-keyword">#+title:</span><span class="comment">       </span><span class="org-document-title">GNU Emacs Lisp Reference Manual Learning Notes</span>
<span class="org-document-info-keyword">#+AUTHOR:</span><span class="comment">      </span><span class="org-document-info">Kelvin Hu</span>
<span class="org-document-info-keyword">#+EMAIL:</span><span class="comment">       </span><span class="org-document-info">ini.kelvin@gmail.com</span>
<span class="org-document-info-keyword">#+DATE:</span><span class="comment">        </span><span class="org-document-info">2012-07-21 Sat</span>
<span class="org-meta-line">#+KEYWORDS:    emacs, elisp</span>
<span class="org-meta-line">#+CATEGORY:    notes</span>
<span class="org-meta-line">#+TAGS:        :Emacs:Elisp:</span>
<span class="org-meta-line">#+LANGUAGE:    en</span>
<span class="org-meta-line">#+OPTIONS:     H:3 num:nil toc:nil \n:nil @:t ::t |:t ^:nil -:t f:t *:t &lt;:t</span>
<span class="org-meta-line">#+DESCRIPTION: learning notes of GNU Emacs Lisp Reference Manual</span>

Notes recorded during learning <span class="italic">/Emacs Lisp Reference Manual/</span>, I did not finish
the whole book, only 12 chapters.

<span class="org-level-1">* Introduction</span>

<span class="org-level-2">** </span><span class="org-level-2"><span class="org-code">=nil=</span></span><span class="org-level-2"> and </span><span class="org-level-2"><span class="org-code">=t=</span></span>

   - <span class="org-code">=nil=</span>
     1. symbol with name "nil"
     2. logical truth value <span class="org-code">=false=</span>
     3. empty list

   - <span class="org-code">=t=</span>
     1. truth value t
     2. symbol "t"

   - <span class="org-code">=booleanp=</span> <span class="italic">/obj/</span>
     return non-=nil= if <span class="italic">/obj/</span> is t or nil, otherwise not

<span class="org-level-2">** version info</span>

   - <span class="org-code">=emacs-version=</span> <span class="bold">*&amp;optional*</span> <span class="italic">/here/</span> function

   - <span class="org-code">=emacs-build-time=</span>                 variable

   - <span class="org-code">=emacs-version=</span>                    variable

   - <span class="org-code">=emacs-major-version=</span>              variable

   - <span class="org-code">=emacs-minor-version=</span>              variable

<span class="org-level-1">* Data Types</span>

  one object can have <span class="bold">*only one*</span> primitive type, but may can belong to several o<span class="whitespace-line">ther types\\</span>
  primitive types are: <span class="org-code">=integer, float, cons, symbol, string, vector, hash-table</span><span class="whitespace-line">, subr, byte-code function=</span>

<span class="org-level-2">** character type</span>

   the read syntax of basic char is ?&lt;X&gt;, &lt;X&gt; stands for the character to be rep<span class="whitespace-line">resented, so ?A stands for 'A'</span>

<span class="org-level-2">** equality predicates</span>

   - <span class="org-code"><span class="bold">=eq=</span></span><span class="bold"> </span><span class="italic"><span class="bold">/obj1/</span></span><span class="bold"> </span><span class="italic"><span class="bold">/obj2/</span></span><span class="bold"> ::</span> return <span class="org-code">=t=</span> if <span class="italic">/obj1/</span> and <span class="italic">/obj2/</span> are the same object, <span class="whitespace-line">otherwise return =nil=\\</span>
        integers with same value are considered to be the same object, so <span class="org-code">=(eq 1</span><span class="whitespace-line"> 1)= will return =t=\\</span>
        exception: <span class="org-code">=(eq "abc" "abc")=</span> will return <span class="org-code">=nil=</span>, but <span class="org-code">=(eq "" "")=</span> will r<span class="whitespace-line">eturn =t= because the empty string is only stored one copy\\</span>
        as expected, <span class="org-code">=(eq '(1 2 3) '(1 2 3))=</span> will return <span class="org-code">=nil=</span>

   - <span class="org-code"><span class="bold">=equal=</span></span><span class="bold"> </span><span class="italic"><span class="bold">/obj1/</span></span><span class="bold"> </span><span class="italic"><span class="bold">/obj2/</span></span><span class="bold"> ::</span> return <span class="org-code">=t=</span> if <span class="italic">/obj1/</span> and <span class="italic">/obj2/</span> have equal compone<span class="whitespace-line">nts, otherwise return =nil=\\</span>
        unlike <span class="org-code">=eq=</span>, <span class="org-code">=equal=</span> will look into arguments to check if there contents<span class="whitespace-line"> are the same, if /obj1/ and /obj2/ are =eq=, they must be =equal=</span>
        so, as expected, <span class="org-code">=(equal '(1 2 3) '(1 2 3))=</span> and <span class="org-code">=(equal "abc" "abc")=</span> w<span class="whitespace-line">ill both return =t=</span>

<span class="org-level-1">* Numbers</span>

<span class="org-level-2">** two types</span>

   - <span class="org-code">=integer=</span>
   - <span class="org-code">=float=</span>

<span class="org-level-2">** type predicates functions</span>

   - <span class="org-code">=floatp=</span> <span class="italic">/object/</span>
   - <span class="org-code">=integerp=</span> <span class="italic">/object/</span>
   - <span class="org-code">=numberp=</span> <span class="italic">/object/</span>
   - <span class="org-code">=natnump=</span> <span class="italic">/object/</span> : returns <span class="org-code">=t=</span> if <span class="italic">/object/</span> is a natural number, such as 0<span class="whitespace-line">, 1, 2...</span>
   - <span class="org-code">=zerop=</span> <span class="italic">/object/</span>

<span class="org-level-2">** comparison functions</span>

   - <span class="org-code">=max=</span> <span class="italic">/num1/</span> <span class="bold">*&amp;rest*</span> <span class="italic">/nums/</span> return the maximum value

   - <span class="org-code">=min=</span> <span class="italic">/num1/</span> <span class="bold">*&amp;rest*</span> <span class="italic">/nums/</span> return the minimun value

<span class="org-level-2">** conversion functions</span>

   - <span class="org-code">=float=</span> <span class="italic">/number/</span> convert the <span class="italic">/number/</span> to float type

   - <span class="org-code">=truncate=</span> <span class="italic">/number/</span> <span class="bold">*&amp;optional*</span> <span class="italic">/divisor/</span> convert the <span class="italic">/number/</span> to integer b<span class="whitespace-line">y rounding towards zero</span>

   - <span class="org-code">=floor=</span> <span class="italic">/number/</span> <span class="bold">*&amp;optional*</span> <span class="italic">/divisor/</span> convert the <span class="italic">/number/</span> to integer by r<span class="whitespace-line">ounding towards negative infinity</span>

   - <span class="org-code">=ceiling=</span> <span class="italic">/number/</span> <span class="bold">*&amp;optional*</span> <span class="italic">/divisor/</span> convert the <span class="italic">/number/</span> to integer by<span class="whitespace-line"> rounding towards positive infinity</span>

   - <span class="org-code">=round=</span> <span class="italic">/number/</span> <span class="bold">*&amp;optional*</span> <span class="italic">/divisor/</span> convert the <span class="italic">/number/</span> to integer by r<span class="whitespace-line">ounding towards nearest integer</span>

<span class="org-level-2">** random function</span>

   - <span class="org-code">=random=</span> <span class="bold">*&amp;optional*</span> <span class="italic">/limit/</span> returns a pseudo-random integer\\
     if <span class="italic">/limit/</span> is a positive integer, the value is chosen in [0, limit), and of<span class="whitespace-line"> course only choose integer</span>
     if <span class="italic">/limit/</span> is <span class="org-code">=t=</span>, it will choose a new seed, otherwise Emacs will always u<span class="whitespace-line">se the same seed, so the returned</span>
        pseudo-random integer sequences are always the same

<span class="org-level-1">* Strings and Characters</span>

<span class="org-level-2">** predicates functions</span>

   - <span class="org-code">=stringp=</span> <span class="italic">/object/</span>
   - <span class="org-code">=string-or-null-p=</span> <span class="italic">/object/</span>
   - <span class="org-code">=char-or-string-p=</span> <span class="italic">/object/</span>

<span class="org-level-2">** useful functions</span>

   - <span class="org-code">=substring=</span> : to get substring
   - <span class="org-code">=concat=</span> : to concatenate strings together
   - <span class="org-code">=split-string=</span> : split string into several strings
   - <span class="org-code">=string==</span> / <span class="org-code">=string-equal=</span> : judge the equality of two strings
   - <span class="org-code">=string-prefix-p=</span> : check if a string is a prefix of another
   - <span class="org-code">=downcase=</span> / <span class="org-code">=upcase=</span> : change a string or a character to opposite case

<span class="org-level-1">* Lists</span>

<span class="org-level-2">** cons cells</span>

   a cons cell has two slots, the first is called CAR and the second is called C<span class="whitespace-line">DR, and it may looks like the structure below:</span>

<span class="org-block-begin-line">   #+begin_src c
</span><span class="org-block">       struct cons_cell {
           void * CAR;
           void * CDR;
       };
</span><span class="org-block-end-line">   #+end_src
</span>
   so the two slots can hold any values, and lists are built up from cons cell, <span class="whitespace-line">which stores object pointer in CAR slot, and stores the nexe node pointer in CDR slot</span>

<span class="org-level-2">** element accessing functions</span>

   - <span class="org-code">=car=</span> / <span class="org-code">=cdr=</span>
   - <span class="org-code">=pop=</span>
   - <span class="org-code">=nth=</span> / <span class="org-code">=nthcdr=</span>
   - <span class="org-code">=last=</span>

<span class="org-level-2">** building functions</span>

   - <span class="org-code">=cons=</span>
   - <span class="org-code">=list=</span>
   - <span class="org-code">=make-list=</span>
   - <span class="org-code">=append=</span>
   - <span class="org-code">=reverse=</span>
   - <span class="org-code">=number-sequence=</span>

<span class="org-level-2">** modification functions</span>

   - <span class="org-code">=push=</span>
   - <span class="org-code">=add-to-list=</span>
   - <span class="org-code">=setcar=</span> / <span class="org-code">=setcdr=</span>

   - <span class="org-code">=nconc=</span> <span class="bold">*&amp;rest*</span> <span class="italic">/lists/</span> : return a list containing all the elements of <span class="italic">/lis</span><span class="whitespace-line">ts/, last CDR of each given list is set to point to next list</span>

   - <span class="org-code">=memq=</span> <span class="italic">/object/</span> <span class="italic">/list/</span> : test if <span class="italic">/object/</span> is in <span class="italic">/list/</span>, if is in, return th<span class="whitespace-line">e sublist from the position /object/ occurs the first time</span>

   - <span class="org-code">=delq=</span> <span class="italic">/object/</span> <span class="italic">/list/</span> : delete all occurrences of <span class="italic">/object/</span> in <span class="italic">/list/</span>, note<span class="whitespace-line"> that it uses =eq= to check if two objects are equal, same as =memq=</span>

   - <span class="org-code">=remq=</span> <span class="italic">/object/</span> <span class="italic">/list/</span> : returns a list copy with all elements <span class="org-code">=eq=</span> to <span class="italic">/obj</span><span class="whitespace-line">ect/ removed</span>

   - <span class="org-code">=member=</span> <span class="italic">/object/</span> <span class="italic">/list/</span> : like <span class="org-code">=memq=</span>, only difference is it uses <span class="org-code">=equal=</span> <span class="whitespace-line">to check the equality of two objects</span>

   - <span class="org-code">=delete=</span> <span class="italic">/object/</span> <span class="italic">/sequence/</span> : like <span class="org-code">=delq=</span>, but uses <span class="org-code">=equal=</span> for comparison

   - <span class="org-code">=remove=</span> <span class="italic">/object/</span> <span class="italic">/sequence/</span> : like <span class="org-code">=delete=</span>, but it always returns a copy <span class="whitespace-line">of processed /sequence/, no matter /sequence/ is a list, vector, or a string</span>

<span class="org-level-2">** association lists</span>

   <span class="italic">/alist/</span> for short, it is a list consists of cons cells, that is to say, every<span class="whitespace-line"> element of alist is a cons cell, the CAR of the cons cell stores\\</span>
   <span class="bold">*key*</span> while the CDR stores <span class="bold">*value*</span>

   - <span class="org-code">=assoc=</span> <span class="italic">/key/</span> <span class="italic">/alist/</span> : returns the first occurrence of <span class="italic">/key/</span> in <span class="italic">/alist/</span>, u<span class="whitespace-line">ses =equal= for comparison, note that it returns the whole cons cell,\\</span>
     not only the CDR

   - <span class="org-code">=rassoc=</span> <span class="italic">/value/</span> <span class="italic">/alist/</span> : like <span class="org-code">=assoc=</span>, but uses CDR for comparison, <span class="org-code">=asso</span><span class="whitespace-line">c= uses CAR</span>

   - <span class="org-code">=assq=</span> <span class="italic">/key/</span> <span class="italic">/alist/</span> : like <span class="org-code">=assoc=</span>, but uses <span class="org-code">=eq=</span> for comparison

   - <span class="org-code">=rassq=</span> <span class="italic">/value/</span> <span class="italic">/alist/</span> : ...

   - <span class="org-code">=assq-delete-all=</span> / <span class="org-code">=rassq-delete-all=</span> : ...

<span class="org-level-1">* Sequences, Arrays and Vectors</span>

  sequence: list, array
  array: vector, string, char-table, bool-vector

<span class="org-level-2">** sequence functions</span>

   - <span class="org-code">=sequencep=</span>
   - <span class="org-code">=length=</span>

   - <span class="org-code">=elt=</span> <span class="italic">/sequence/</span> <span class="italic">/index/</span> : returns the element of <span class="italic">/sequence/</span> at <span class="italic">/index/</span>

<span class="org-level-2">** array functions</span>

   - <span class="org-code">=arrayp=</span>

   - <span class="org-code">=aref=</span> <span class="italic">/array/</span> <span class="italic">/index/</span> : returns element of <span class="italic">/array/</span> at <span class="italic">/index/</span>

   - <span class="org-code">=aset=</span> <span class="italic">/array/</span> <span class="italic">/index/</span> <span class="italic">/object/</span> : set <span class="italic">/object/</span> to the <span class="italic">/index/</span> element of <span class="italic">/a</span><span class="whitespace-line">rray/</span>

   - <span class="org-code">=fillarray=</span> <span class="italic">/array/</span> <span class="italic">/object/</span> : fills <span class="italic">/array/</span> with <span class="italic">/object/</span>

<span class="org-level-2">** vector functions</span>

   - <span class="org-code">=vectorp=</span>

   - <span class="org-code">=vector=</span> <span class="bold">*&amp;rest*</span> <span class="italic">/objects/</span> : creates a vector with <span class="italic">/objects/</span>

   - <span class="org-code">=make-vector=</span> <span class="italic">/length/</span> <span class="italic">/object/</span> : makes a vector has <span class="italic">/length/</span> and filled by<span class="whitespace-line"> /object/</span>

   - <span class="org-code">=vconcat=</span> <span class="bold">*&amp;test*</span> <span class="italic">/sequences/</span> : returns a new vector containing all element<span class="whitespace-line">s in /sequences/</span>

<span class="org-level-2">** char-table, bool-vector (skipped)</span>

   not so useful, so skip them

<span class="org-level-1">* Hash Tables (skipped)</span>

  not so useful, so skip it

<span class="org-level-1">* Symbols</span>

<span class="org-level-2">** symbol components</span>

   each symbol has four components:

   - print name: the name of the symbol

   - value: symbol's current value as a variable

   - function: symbol's function definition, can also hold a symbol, a keymap, o<span class="whitespace-line">r a keyboard macro</span>

   - property list: symbol's property list

<span class="org-level-2">** create and intern symbols</span>

   symbols are stored in a vector called <span class="italic">/obarray/</span>, symbol name and symbol is wi<span class="whitespace-line">th a one-to-one mapping relationship\\</span>
   interning a symbol means hash it and put it into <span class="italic">/obarray/</span>, or find it from <span class="italic">/</span><span class="whitespace-line">obarray/, so there will never be two symbols with same name in one /obarray/,\\</span>
   or two names pointing to one symbol.

   <span class="org-code">=*intern*=</span> : find a symbol from <span class="italic">/obarray/</span>, or create a new symbol and put it <span class="whitespace-line">into /obarray/. *so the finding action is also a interning operation*</span>

   of course there are <span class="italic">/uninterned symbols/</span>, it means they are not put into any <span class="whitespace-line">/obarray/, they may exist in some other object or as variable values</span>

<span class="org-level-2">** functions</span>

   - <span class="org-code">=symbol-name=</span>
   - <span class="org-code">=make-symbol=</span>

   - <span class="org-code">=intern=</span> <span class="italic">/name/</span> <span class="bold">*&amp;optional*</span> <span class="italic">/obarray/</span> : returns the interned symbol with na<span class="whitespace-line">me /name/, creates a new one and puts it into /obarray/ if no symbol found</span>
   - <span class="org-code">=intern-soft=</span> <span class="italic">/name/</span> <span class="bold">*&amp;optional*</span> <span class="italic">/obarray/</span> : returns the already interned s<span class="whitespace-line">ymbol with name /name/, returns =nil= if not found</span>

   - <span class="org-code">=mapatoms=</span> <span class="italic">/function/</span> <span class="bold">*&amp;optional*</span> <span class="italic">/obarray/</span> : calls <span class="italic">/function/</span> once with ea<span class="whitespace-line">ch symbol in /obarray/, then returns =nil=</span>

<span class="org-level-2">** property list</span>

   property list (so called <span class="italic">/plist/</span>) is like association list (<span class="italic">/alist/</span>), it is a<span class="whitespace-line">lso key-value pair data structure, but it often uses symbol as the key, so a plist\\</span>
   may always have unique keys, while alist may not.

<span class="org-level-2">** plist functions</span>

   - <span class="org-code">=symbol-plist=</span> <span class="italic">/symbol/</span>
   - <span class="org-code">=setplist=</span> <span class="italic">/symbol/</span> <span class="italic">/plist/</span>
   - <span class="org-code">=get=</span> <span class="italic">/symbol/</span> <span class="italic">/property/</span>
   - <span class="org-code">=put=</span> <span class="italic">/symbol/</span> <span class="italic">/property/</span> <span class="italic">/value/</span>
   - <span class="org-code">=plist-get=</span> <span class="italic">/plist/</span> <span class="italic">/property/</span>
   - <span class="org-code">=plist-put=</span> <span class="italic">/plist/</span> <span class="italic">/property/</span> <span class="italic">/value/</span>
   - <span class="org-code">=plist-member=</span> <span class="italic">/plist/</span> <span class="italic">/property/</span>

<span class="org-level-1">* Evaluation</span>

  a Lisp object that is intended for evaluation is called a <span class="italic">/form/</span> or <span class="italic">/expressio</span><span class="whitespace-line">n/, or /S-expression/</span>
  any Lisp object can be evaluated, but in practice only numbers, string, symbol<span class="whitespace-line">s, lists are evaluated very often</span>

<span class="org-level-2">** kinds of forms</span>

   how Emacs evaluates a form depends on its data type: symbols, lists, and "all<span class="whitespace-line"> other data types"</span>

   - self-evaluating forms: "all other data types"
     the result of self-evaluating is the object itself, so 25 will be evaluated<span class="whitespace-line"> to 25, "abc" will be evaluated to "abc"</span>

   - symbol forms: will be evaluated as a variable, so its value field will be r<span class="whitespace-line">eturned</span>

   - list forms: the evaluating way of a list is determined by its first element<span class="whitespace-line">, if first element is:</span>
     - a symbol: the symbol's function field will be obtained and replace the sy<span class="whitespace-line">mbol with that function</span>
     - a function: evaluates the remaining elements of the list first, and then <span class="whitespace-line">call the function with these evaluated remaining elements as parameters</span>
     - a macro: evaluates the macro with the remaining elements as parameters wi<span class="whitespace-line">thout evaluating the remaining elements</span>
     - special forms: such as <span class="italic">/if/</span>, <span class="italic">/and/</span>, evaluation of elements in the list de<span class="whitespace-line">pends on the special forms' syntax requirements</span>

<span class="org-level-1">* Control Structures (skipped)</span>

  things about special forms for flow control, such as <span class="italic">/if/</span>, <span class="italic">/progn/</span>, <span class="italic">/cond/</span>, <span class="italic">/w</span><span class="whitespace-line">hile/, so skip it</span>

<span class="org-level-1">* Variables</span>

<span class="org-level-2">** local variables</span>

   - <span class="org-code">=let=</span> <span class="italic">/bindings.../</span> <span class="italic">/forms.../</span>
   - <span class="org-code">=let*=</span> <span class="italic">/bindings.../</span> <span class="italic">/forms.../</span> : like <span class="org-code">=let=</span>, difference is a local variabl<span class="whitespace-line">e binding will take effect immediately before next local variable binding takes place</span>

   - <span class="org-code">=makeunbound=</span> <span class="italic">/symbol/</span> : cancel the <span class="italic">/symbol/</span>'s binding to a value
   - <span class="org-code">=boundp=</span> <span class="italic">/variable/</span> : to judge if the variable is bound, returns <span class="org-code">=t=</span> if its<span class="whitespace-line"> value is not *void*</span>

<span class="org-level-2">** global variables</span>

   global variables can be defined by <span class="org-code">=defvar=</span> and <span class="org-code">=defconst=</span>, they do not have <span class="whitespace-line">actually difference, =defconst= is intent to inform human readers that the variable\\</span>
   may should not be changed, but actually its value can be changed

<span class="org-level-1">* Functions</span>

  function types:
  - lambda expression
  - primitive : written in C
  - special form : like <span class="org-code">=if=</span>, <span class="org-code">=and=</span>, <span class="org-code">=while=</span>
  - macro
  - command : (includes <span class="italic">/keyboard macros/</span>)
  - closure
  - byte-code function
  - autoload object

<span class="org-level-2">** mapping functions</span>

   - <span class="org-code">=mapcar=</span> <span class="italic">/function/</span> <span class="italic">/sequence/</span> : applies <span class="italic">/function/</span> to each element in <span class="italic">/seq</span><span class="whitespace-line">uence/ in turn, return a list of results</span>
   - <span class="org-code">=mapc=</span> <span class="italic">/function/</span> <span class="italic">/sequence/</span> : like <span class="org-code">=mapcar=</span>, but it is used for side effec<span class="whitespace-line">ts, return value will be ignored</span>
   - <span class="org-code">=mapconcat=</span> <span class="italic">/function/</span> <span class="italic">/sequence/</span> <span class="italic">/separator/</span> : like <span class="org-code">=mapcar=</span>, but <span class="italic">/functio</span><span class="whitespace-line">n/'s result must be string, and the strings will be concatenated as return value</span>



--------------------------------------------------------------------------------<span class="whitespace-line">----------</span>
</pre>
  </body>
</html>
